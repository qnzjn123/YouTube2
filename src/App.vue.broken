<template>
  <div class="app">
    <div class="sidebar">
      <div class="sidebar-item" :class="{ active: currentView === 'home' }" @click="setCurrentView('home')">
        <div class="sidebar-icon">
          <svg viewBox="0 0 24 24" class="home-icon">
            <path d="M12 4 5 10v10h14V10L12 4z" fill="none" stroke="currentColor" stroke-width="1.5"></path>
            <path d="M9 14v6 M15 14v6" stroke="currentColor" stroke-width="1.5"></path>
          </svg>
        </div>
        <div class="sidebar-text">홈</div>
      </div>
      
      <div class="sidebar-item" :class="{ active: currentView === 'shorts' }" @click="setCurrentView('shorts')">
        <div class="sidebar-icon">
          <svg viewBox="0 0 24 24" class="shorts-icon">
            <path d="M10 14.65v-5.3L15 12l-5 2.65zm7.77-4.33c-.77-.32-1.2-.5-1.2-.5L18 9.06c1.84-.96 2.53-3.23 1.56-5.06s-3.24-2.53-5.07-1.56L6 6.94c-1.29.68-2.07 2.04-2 3.49.07 1.42.93 2.67 2.22 3.25.03.01 1.2.5 1.2.5L6 14.93c-1.83.97-2.53 3.24-1.56 5.07.97 1.83 3.24 2.53 5.07 1.56l8.5-4.5c1.29-.68 2.06-2.04 1.99-3.49-.07-1.42-.94-2.68-2.23-3.25zm-.23 5.86l-8.5 4.5c-1.34.71-3.01.2-3.72-1.14-.71-1.34-.2-3.01 1.14-3.72l2.04-1.08v-1.21l-.69-.28-1.11-.46c-.99-.41-1.65-1.35-1.7-2.41-.05-1.06.52-2.06 1.46-2.56l8.5-4.5c1.34-.71 3.01-.2 3.72 1.14.71 1.34.2 3.01-1.14 3.72L15.5 9.26v1.21l1.8.74c.99.41 1.65 1.35 1.7 2.41.05 1.06-.52 2.06-1.46 2.56z"></path>
          </svg>
        </div>
        <div class="sidebar-text">쇼츠</div>
      </div>

      <div class="sidebar-item" :class="{ active: currentView === 'history' }" @click="setCurrentView('history')">
        <div class="sidebar-icon">
          <svg viewBox="0 0 24 24" class="history-icon">
            <path d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"></path>
          </svg>
        </div>
        <div class="sidebar-text">시청기록</div>
      </div>
    </div>
    
    <nav class="menu-bar">
      <div class="logo-container">
        <div class="youtube-logo">
          <div class="play-button"></div>
          <div class="youtube-text">YouTube<span class="kr">KR</span></div>
        </div>
      </div>
      
      <div class="search-container">
        <form class="search-form" @submit.prevent="searchVideos">
          <input 
            type="text" 
            placeholder="검색" 
            class="search-input" 
            v-model="searchQuery" 
            @focus="handleSearchFocus"
            readonly
          >
          <button type="submit" class="search-button">
            <svg viewBox="0 0 24 24" class="search-icon">
              <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
            </svg>
          </button>
          <button 
            v-if="searchQuery.trim()" 
            type="button" 
            class="search-clear-button" 
            @click="clearSearch"
            title="검색 초기화"
          >
            <svg viewBox="0 0 24 24" class="clear-icon">
              <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"></path>
            </svg>
          </button>
          
          <!-- 검색 결과 드롭다운 -->
          <div class="search-results-dropdown" v-if="searchQuery.trim() && showSearchResults">
            <div v-if="filteredVideos.length === 0" class="no-results">
              '{{ searchQuery }}'에 대한 결과가 없습니다
            </div>
            <div v-else class="search-results-list">
              <div 
                v-for="(video, index) in filteredVideos" 
                :key="index" 
                class="search-result-item"
                @click="selectSearchResult(video)"
              >
                <div class="search-result-thumbnail">
                  <video :src="video.url" v-if="video.url && !video.isRefreshed"></video>
                  <div class="thumbnail-placeholder" v-else>
                    <svg viewBox="0 0 24 24" class="video-placeholder-icon">
                      <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 14.5v-9l6 4.5-6 4.5z"></path>
                    </svg>
                  </div>
                </div>
                <div class="search-result-info">
                  <div class="search-result-title">{{ video.title }}</div>
                  <div class="search-result-meta">{{ formatDate(video.uploadDate) }} • {{ formatFileSize(video.size) }}</div>
                </div>
              </div>
            </div>
          </div>
        </form>
      </div>
      
      <div class="action-buttons">
        <div class="create-dropdown">
          <button class="create-button" @click="toggleCreateMenu">
            <span class="plus-icon">+</span>
            <span class="create-text">만들기</span>
          </button>
          <div class="dropdown-menu" v-if="showCreateMenu">
            <div class="dropdown-item" @click="openUploadModal">
              <svg viewBox="0 0 24 24" class="upload-icon">
                <path d="M14 13l-4 5V3h-2v15l4-5v3h2v-3z"/>
                <path d="M18 9h-3v2h3v9H6v-9h3V9H6c-1.1 0-2 .9-2 2v9c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-9c0-1.1-.9-2-2-2z"/>
              </svg>
              <span>동영상 업로드</span>
            </div>
          </div>
        </div>
        <div class="notification-wrapper">
          <button class="notification-button" @click="() => { showNotificationPanel = !showNotificationPanel }">
            <svg viewBox="0 0 24 24" class="bell-icon">
              <path d="M12 22c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2zm6-6v-5c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2z"></path>
            </svg>
            <span class="notification-badge" v-if="notificationList.length > 0">{{ notificationList.length }}</span>
          </button>
          
          <!-- 알림 패널 -->
          <div class="notification-panel" v-if="showNotificationPanel">
            <div class="notification-panel-header">
              <h3>알림</h3>
              <button class="clear-all" @click="clearAllNotifications" v-if="notificationList.length > 0">모두 지우기</button>
            </div>
            <div class="notification-panel-content">
              <div v-if="notificationList.length === 0" class="no-notifications">
                알림이 없습니다.
              </div>
              <div v-for="(notification, index) in notificationList" :key="index" class="notification-item">
                <div class="notification-item-icon">
                  <svg viewBox="0 0 24 24" class="success-icon">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"></path>
                  </svg>
                </div>
                <div class="notification-item-content">
                  <div class="notification-item-title">{{ notification.title }}</div>
                  <div class="notification-item-message">{{ notification.message }}</div>
                  <div class="notification-item-time">{{ formatNotificationTime(notification.time) }}</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </nav>
    <div class="main-content">
      <header>
        <div class="search-header" v-if="isSearchActive">
          <h2>
            <span v-if="filteredVideos.length">
              '{{ searchQuery }}' 검색 결과 ({{ filteredVideos.length }}개)
            </span>
            <span v-else>
              '{{ searchQuery }}'에 대한 검색 결과가 없습니다
            </span>
          </h2>
          <button class="reset-search-button" @click="clearSearch">
            <svg viewBox="0 0 24 24" class="reset-icon">
              <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"></path>
            </svg>
            필터링 초기화
          </button>
        </div>
        <div class="view-header" v-if="currentView === 'shorts'">
          <h2>쇼츠</h2>
          <p>50초 이하의 짧은 동영상</p>
        </div>
        <div class="view-header" v-if="currentView === 'history'">
          <div class="view-header-content">
            <h2>시청기록</h2>
            <p>시청한 동영상의 기록이 여기에 표시됩니다</p>
          </div>
          <button v-if="watchHistory.length > 0" class="clear-history-button" @click="confirmClearHistory">
            <svg viewBox="0 0 24 24" class="delete-all-icon">
              <path d="M15 4V3H9v1H4v2h1v13c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V6h1V4h-5zm2 15H7V6h10v13zM9 8h2v9H9zm4 0h2v9h-2z"></path>
            </svg>
            시청 기록 비우기
          </button>
        </div>
      </header>
      <main>
        <!-- 기존 비디오 컨테이너 -->
        <div class="videos-container" v-if="currentView === 'home'">
          <div v-if="!videos || !videos.length" class="no-videos">
            동영상이 없습니다. '만들기' 버튼을 클릭하여 첫 동영상을 업로드하세요!
          </div>
          <div v-else-if="normalVideos && normalVideos.length" v-for="(video, index) in normalVideos" :key="index" class="video-card">
            <div class="video-thumbnail" @click="openVideoDetail(video)">
              <video :src="video.url" controls v-if="video.url"></video>
              <div class="thumbnail-placeholder" v-else>
                <div class="refresh-notice" v-if="video.isRefreshed">
                  <svg viewBox="0 0 24 24" class="refresh-icon">
                    <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 9h7V2l-2.35 4.35z"/>
                  </svg>
                  <div class="refresh-text">
                    <div>새로고침 후 재생할 수 없습니다.</div>
                    <div>새 비디오를 업로드하세요.</div>
                  </div>
                </div>
                <svg v-else viewBox="0 0 24 24" class="video-placeholder-icon">
                  <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 14.5v-9l6 4.5-6 4.5z"></path>
                </svg>
              </div>
              <button class="video-delete-button" @click.stop="deleteVideo(video.id)" title="삭제">
                <svg viewBox="0 0 24 24" class="trash-icon">
                  <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path>
                </svg>
              </button>
            </div>
            <div class="video-info" @click="openVideoDetail(video)">
              <div class="video-header">
                <h3 class="video-title">{{ video.title || '제목 없음' }}</h3>
              </div>
              <p class="video-details">
                {{ formatDate(video.uploadDate) }} 
                <span class="video-size">{{ formatFileSize(video.size) }}</span>
              </p>
            </div>
          </div>
        </div>

        <!-- 쇼츠 컨테이너 추가 -->
        <div class="shorts-container" v-if="currentView === 'shorts'">
          <div v-if="!videos || !videos.length || !(shortsVideos && shortsVideos.length)" class="no-videos shorts-no-videos">
            쇼츠가 없습니다. '만들기' 버튼을 클릭하여 짧은 동영상을 업로드하세요!
          </div>
          <div class="shorts-list" v-else-if="shortsVideos && shortsVideos.length">
            <div v-for="(video, index) in shortsVideos" :key="index" class="shorts-card">
              <div class="shorts-thumbnail">
                <video 
                  :src="video.url" 
                  controls 
                  loop 
                  autoplay
                  muted 
                  controlsList="nodownload nofullscreen" 
                  v-if="video.url && !video.isRefreshed" 
                ></video>
                <div class="thumbnail-placeholder" v-else>
                  <div class="refresh-notice" v-if="video.isRefreshed">
                    <svg viewBox="0 0 24 24" class="refresh-icon">
                      <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 9h7V2l-2.35 4.35z"/>
                    </svg>
                    <div class="refresh-text">
                      <div>새로고침 후 재생할 수 없습니다.</div>
                      <div>새 비디오를 업로드하세요.</div>
                    </div>
                  </div>
                  <svg v-else viewBox="0 0 24 24" class="video-placeholder-icon">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 14.5v-9l6 4.5-6 4.5z"></path>
                  </svg>
                </div>
                
                <!-- 쇼츠 옵션 메뉴 버튼 (점 세 개) -->
                <button class="shorts-menu-button" @click.stop="openShortsMenu(video.id)">
                  <svg viewBox="0 0 24 24" class="menu-icon">
                    <path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path>
                  </svg>
                </button>
                
                <!-- 쇼츠 옵션 메뉴 드롭다운 -->
                <div v-if="activeMenuId === video.id" class="shorts-menu-dropdown">
                  <div class="menu-item" @click="confirmDeleteShorts(video.id)">
                    <svg viewBox="0 0 24 24" class="delete-icon">
                      <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path>
                    </svg>
                    <span>삭제</span>
                  </div>
                </div>
                
                <div class="shorts-controls">
                  <div class="shorts-like">
                    <svg viewBox="0 0 24 24" class="like-icon">
                      <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-1.91l-.01-.01L23 10z"></path>
                    </svg>
                    <span>좋아요</span>
                  </div>
                  <div class="shorts-dislike">
                    <svg viewBox="0 0 24 24" class="dislike-icon">
                      <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v1.91l.01.01L1 14c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"></path>
                    </svg>
                    <span>싫어요</span>
                  </div>
                  <div class="shorts-comment">
                    <svg viewBox="0 0 24 24" class="comment-icon">
                      <path d="M21.99 4c0-1.1-.89-2-1.99-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18zM18 14H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"></path>
                    </svg>
                    <span>댓글</span>
                  </div>
                  <div class="shorts-share">
                    <svg viewBox="0 0 24 24" class="share-icon">
                      <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"></path>
                    </svg>
                    <span>공유</span>
                  </div>
                </div>
              </div>
              <div class="shorts-info">
                <div class="shorts-header">
                  <h3 class="shorts-title">{{ video.title || '제목 없음' }}</h3>
                </div>
                <p class="shorts-details">
                  <span class="shorts-channel">@{{video.title.substring(0, 4)}} </span>
                  <span class="shorts-duration">{{ formatDuration(video.duration) }}</span>
                </p>
              </div>
            </div>
          </div>
        </div>
        
        <!-- 삭제 확인 모달 -->
        <div class="modal-overlay" v-if="showDeleteModal" @click="cancelDelete"></div>
        <div class="delete-modal" v-if="showDeleteModal">
          <div class="modal-header">
            <h2>쇼츠 삭제</h2>
            <button class="close-button" @click="cancelDelete">×</button>
          </div>
          <div class="modal-content">
            <p>이 쇼츠를 삭제하시겠습니까?</p>
            <div class="delete-actions">
              <button class="cancel-button" @click="cancelDelete">취소</button>
              <button class="delete-button" @click="confirmDelete">삭제</button>
            </div>
          </div>
        </div>

        <!-- 시청기록 컨테이너 -->
        <div class="videos-container" v-if="currentView === 'history'">
          <div v-if="watchHistory.length === 0" class="no-videos">
            시청 기록이 없습니다. 동영상을 시청하면 이곳에 표시됩니다.
          </div>
          <div v-else>
            <div v-for="(item, index) in watchHistory" :key="index" class="video-card history-item">
              <div class="video-thumbnail" @click="openVideoDetail(item.video)">
                <video :src="item.video.url" controls v-if="item.video.url && !item.video.isRefreshed"></video>
                <div class="thumbnail-placeholder" v-else>
                  <div class="refresh-notice" v-if="item.video.isRefreshed">
                    <svg viewBox="0 0 24 24" class="refresh-icon">
                      <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 9h7V2l-2.35 4.35z"/>
                    </svg>
                    <div class="refresh-text">
                      <div>새로고침 후 재생할 수 없습니다.</div>
                      <div>새 비디오를 업로드하세요.</div>
                    </div>
                  </div>
                  <svg v-else viewBox="0 0 24 24" class="video-placeholder-icon">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 14.5v-9l6 4.5-6 4.5z"></path>
                  </svg>
                </div>
                <div class="video-badge" v-if="item.video.isShort">쇼츠</div>
              </div>
              <div class="video-info">
                <div class="video-header">
                  <h3 class="video-title">{{ item.video.title || '제목 없음' }}</h3>
                </div>
                <p class="video-details">
                  <span class="watched-date">{{ formatDate(item.watchedAt) }} 시청</span>
                  <span class="video-duration" v-if="item.video.duration">{{ formatDuration(item.video.duration) }}</span>
                </p>
                <button class="remove-history-button" @click="removeFromHistory(item.id)" title="기록에서 삭제">
                  <svg viewBox="0 0 24 24" class="remove-icon">
                    <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"></path>
                  </svg>
                  기록에서 삭제
                </button>
              </div>
            </div>
          </div>
        </div>
        
        <!-- 비디오 상세 페이지 (모달 대신 메인 콘텐츠에 표시) -->
        <div class="video-detail-container" v-if="currentView === 'videoDetail'">
          <div class="video-detail-header">
            <button class="back-button" @click="closeVideoDetail">
              <svg viewBox="0 0 24 24" class="back-icon">
                <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"></path>
              </svg>
              돌아가기
            </button>
          </div>
          
          <div class="video-content-wrapper">
            <div class="video-main-content">
              <div class="video-player-container">
                <video 
                  :src="selectedVideo.url" 
                  controls 
                  autoplay 
                  v-if="selectedVideo.url && !selectedVideo.isRefreshed" 
                  @timeupdate="updateVideoProgress"
                  @ended="handleVideoEnded"
                ></video>
                <div class="thumbnail-placeholder" v-else>
                  <div class="refresh-notice" v-if="selectedVideo.isRefreshed">
                    <svg viewBox="0 0 24 24" class="refresh-icon">
                      <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 9h7V2l-2.35 4.35z"/>
                    </svg>
                    <div class="refresh-text">
                      <div>새로고침 후 재생할 수 없습니다.</div>
                      <div>새 비디오를 업로드하세요.</div>
                    </div>
                  </div>
                  <svg v-else viewBox="0 0 24 24" class="video-placeholder-icon">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 14.5v-9l6 4.5-6 4.5z"></path>
                  </svg>
                </div>
              </div>
              
              <div class="video-detail-info">
                <h1 class="video-detail-title">{{ selectedVideo.title || '제목 없음' }}</h1>
                <div class="video-detail-stats">
                  <span class="video-detail-views">조회수 {{ selectedVideo.views || 0 }}회</span>
                  <span class="video-detail-date">{{ formatDate(selectedVideo.uploadDate) }}</span>
                </div>
                <div class="video-actions">
                  <div class="video-action-button" @click="toggleLike">
                    <svg viewBox="0 0 24 24" :class="{ 'liked': isLiked }">
                      <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-1.91l-.01-.01L23 10z"></path>
                    </svg>
                    <span>{{ selectedVideo.likes || 0 }}</span>
                  </div>
                </div>
              </div>
              
              <!-- 댓글 섹션 -->
              <div class="comments-section">
                <h3 class="comments-title">댓글 {{ comments.length }}개</h3>
                
                <!-- 댓글 작성 폼 -->
                <div class="comment-form">
                  <div class="comment-form-avatar">
                    <svg viewBox="0 0 24 24" class="user-icon">
                      <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"/>
                    </svg>
                  </div>
                  <div class="comment-form-content">
                    <input 
                      type="text" 
                      v-model="newComment" 
                      placeholder="댓글 추가..." 
                      class="comment-input"
                      @keyup.enter="addComment"
                    >
                    <button class="comment-submit" @click="addComment" :disabled="!newComment.trim()">
                      댓글
                    </button>
                  </div>
                </div>
                
                <!-- 댓글 목록 -->
                <div class="comments-list" v-if="!commentLoading">
                  <div v-if="comments.length === 0" class="no-comments">
                    아직 댓글이 없습니다. 첫 댓글을 남겨보세요!
                  </div>
                  <div v-else v-for="comment in comments" :key="comment.id" class="comment-item">
                    <div class="comment-avatar">
                      <svg viewBox="0 0 24 24" class="user-icon">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"/>
                      </svg>
                    </div>
                    <div class="comment-content">
                      <div class="comment-header">
                        <span class="comment-author">{{ comment.author }}</span>
                        <span class="comment-date">{{ formatDate(new Date(comment.createdAt)) }}</span>
                      </div>
                      <div class="comment-text">{{ comment.text }}</div>
                      <div class="comment-actions">
                        <div class="comment-like" @click="likeComment(comment.id)">
                          <svg viewBox="0 0 24 24" class="like-icon">
                            <path d="M9 21h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.58 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2zM9 9l4.34-4.34L12 10h9v2l-3 7H9V9zM1 9h4v12H1z"></path>
                          </svg>
                          <span>{{ comment.likes || 0 }}</span>
                        </div>
                        <button class="comment-delete" @click="deleteComment(comment.id)">
                          삭제
                        </button>
                      </div>
                    </div>
                  </div>
                </div>
                
                <!-- 로딩 표시 -->
                <div v-if="commentLoading" class="comments-loading">
                  댓글 로딩 중...
                </div>
              </div>
            </div>
          </div>
        </div>
      </main>
    </div>
    
    <!-- 비디오 업로드 모달 -->
    <div class="modal-overlay" v-if="showUploadModal" @click="closeModal"></div>
    <div class="upload-modal" v-if="showUploadModal">
      <div class="modal-header">
        <h2>동영상 업로드</h2>
        <button class="close-button" @click="closeModal">×</button>
      </div>
      <div class="modal-content">
        <div class="upload-area" @click="triggerFileInput" @drop.prevent="handleFileDrop" @dragover.prevent>
          <svg viewBox="0 0 24 24" class="upload-cloud-icon">
            <path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z" />
          </svg>
          <h3>동영상 업로드하기</h3>
          <p>클릭하여 파일을 선택하거나 드래그 앤 드롭하세요</p>
          <input 
            type="file" 
            accept="video/*" 
            class="file-input" 
            ref="fileInput"
            @change="handleFileChange" 
            style="display: none" 
          >
        </div>
        <div class="video-details-form" v-if="selectedFile">
          <div class="form-group">
            <label for="video-title">동영상 제목</label>
            <input 
              type="text" 
              id="video-title" 
              v-model="videoTitle" 
              placeholder="제목을 입력하세요" 
              class="title-input"
            >
          </div>
          <div class="file-info">
            <div class="file-name">{{ selectedFile.name }}</div>
            <div class="file-size">{{ formatFileSize(selectedFile.size) }}</div>
          </div>
          <div class="upload-actions">
            <button class="cancel-button" @click="closeModal">취소</button>
            <button class="upload-button" @click="uploadVideo">업로드</button>
          </div>
        </div>
        <div class="upload-progress" v-if="uploading">
          <div class="progress-bar">
            <div class="progress-fill" :style="{width: uploadProgress + '%'}"></div>
          </div>
          <div class="progress-text">{{uploadProgress}}% 완료</div>
        </div>
      </div>
    </div>
    
    <!-- 알림 창 -->
    <div class="notification-container" v-if="notification.show">
      <div class="notification" :class="notification.type">
        <div class="notification-icon">
          <svg v-if="notification.type === 'success'" viewBox="0 0 24 24" class="success-icon">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"></path>
          </svg>
          <svg v-if="notification.type === 'error'" viewBox="0 0 24 24" class="error-icon">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"></path>
          </svg>
        </div>
        <div class="notification-content">
          <div class="notification-title">{{ notification.title }}</div>
          <div class="notification-message">{{ notification.message }}</div>
        </div>
        <button class="notification-close" @click="closeNotification">
          <svg viewBox="0 0 24 24" class="close-icon">
            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"></path>
          </svg>
        </button>
      </div>
    </div>
    
    <!-- 검색 페이지 -->
    <Search 
      v-if="showSearchPage" 
      :videos="videos" 
      @back="closeSearchPage" 
      @selectVideo="selectSearchResult"
    />

    <!-- 시청 기록 비우기 확인 모달 -->
    <div class="modal-overlay" v-if="showClearHistoryModal" @click="cancelClearHistory"></div>
    <div class="delete-modal" v-if="showClearHistoryModal">
      <div class="modal-header">
        <h2>시청 기록 비우기</h2>
        <button class="close-button" @click="cancelClearHistory">×</button>
      </div>
      <div class="modal-content">
        <p>모든 시청 기록을 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.</p>
        <div class="delete-actions">
          <button class="cancel-button" @click="cancelClearHistory">취소</button>
          <button class="delete-button" @click="clearAllHistory">삭제</button>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, computed, watch, nextTick } from 'vue'
import Search from './Search.vue'

// Window 인터페이스 확장
declare global {
  interface Window {
    lastKeyWasF12: boolean;
  }
}

// 비디오 데이터베이스 관리 객체
const videoDB = {
  db: null as IDBDatabase | null,

  // DB 초기화
  async init() {
    return new Promise<void>((resolve, reject) => {
      try {
        console.log('IndexedDB 초기화 시작...');
        
        // 데이터베이스 버전 업그레이드를 위해 높은 버전 번호 사용
        const request = indexedDB.open('videoDatabase', 6); // 버전 업그레이드
        
        request.onerror = (event) => {
          console.error('IndexedDB 열기 실패:', event);
          reject(new Error('IndexedDB 열기 실패'));
        };
        
        request.onblocked = (event) => {
          console.error('IndexedDB 열기가 차단됨:', event);
          reject(new Error('IndexedDB 열기가 차단됨 - 다른 탭을 닫고 다시 시도하세요'));
        };
        
        request.onupgradeneeded = (event) => {
          console.log('IndexedDB 업그레이드 중...');
          const db = (event.target as IDBOpenDBRequest).result;
          
          // 비디오 저장소 생성
          if (!db.objectStoreNames.contains('videos')) {
            console.log('videos 저장소 생성');
            db.createObjectStore('videos', { keyPath: 'id' });
          }
          
          // 쇼츠 저장소 생성
          if (!db.objectStoreNames.contains('shorts')) {
            console.log('shorts 저장소 생성');
            db.createObjectStore('shorts', { keyPath: 'id' });
          }

          // 시청기록 저장소 생성
          if (!db.objectStoreNames.contains('history')) {
            console.log('history 저장소 생성');
            db.createObjectStore('history', { keyPath: 'id', autoIncrement: true });
          }
          
          // 댓글 저장소 생성 (또는 재생성)
          if (db.objectStoreNames.contains('comments')) {
            console.log('기존 comments 저장소 삭제');
            db.deleteObjectStore('comments');
          }
          
          console.log('comments 저장소 생성');
          const commentsStore = db.createObjectStore('comments', { keyPath: 'id', autoIncrement: true });
          commentsStore.createIndex('videoId', 'videoId', { unique: false });
          console.log('videoId 인덱스 생성 완료');
        };
        
        request.onsuccess = (event) => {
          try {
            this.db = (event.target as IDBOpenDBRequest).result;
            
            // 연결된 DB에 필요한 스토어가 모두 있는지 확인
            const requiredStores = ['videos', 'shorts', 'history', 'comments'];
            const missingStores = requiredStores.filter(
              store => !Array.from(this.db.objectStoreNames).includes(store)
            );
            
            if (missingStores.length > 0) {
              console.error(`필요한 스토어가 누락됨: ${missingStores.join(', ')}`);
              this.db.close();
              reject(new Error('데이터베이스 구조 오류: 누락된 스토어가 있습니다'));
              return;
            }
            
            // 댓글 스토어에 videoId 인덱스가 있는지 확인
            try {
              const transaction = this.db.transaction(['comments'], 'readonly');
              const commentsStore = transaction.objectStore('comments');
              if (!commentsStore.indexNames.contains('videoId')) {
                console.warn('comments 스토어에 videoId 인덱스가 없습니다. DB를 재설정해야 할 수 있습니다.');
              } else {
                console.log('comments 스토어의 videoId 인덱스 확인 완료');
              }
            } catch (indexError) {
              console.error('comments 스토어 인덱스 확인 중 오류:', indexError);
            }
            
            console.log('IndexedDB 연결 성공, 버전:', this.db.version);
            
            // DB 연결 오류 처리 이벤트 리스너 추가
            this.db.onerror = (error) => {
              console.error('IndexedDB 오류:', error);
            };
            
            resolve();
          } catch (innerError) {
            console.error('IndexedDB 연결 설정 중 오류:', innerError);
            reject(innerError);
          }
        };
      } catch (outerError) {
        console.error('IndexedDB 초기화 중 예외 발생:', outerError);
        reject(outerError);
      }
    });
  },
  
  // 비디오 저장
  async saveVideo(video: any, isShort: boolean = false) {
    return new Promise<void>((resolve, reject) => {
      if (!this.db) {
        reject(new Error('데이터베이스가 초기화되지 않았습니다'));
        return;
      }
      
      // Blob을 안전하게 저장하기 위해 별도 처리
      let videoToStore = { ...video };
      
      if (videoToStore.blob instanceof Blob) {
        const reader = new FileReader();
        reader.readAsArrayBuffer(videoToStore.blob);
        
        reader.onload = () => {
          try {
            // Blob 데이터를 저장하기 위한 객체 생성
            const videoData = {
              ...videoToStore,
              blobData: reader.result, // ArrayBuffer 형태로 저장
              url: null // URL 오브젝트는 저장할 수 없음
            };
            
            delete videoData.blob; // Blob 객체는 제거
            
            const storeName = isShort ? 'shorts' : 'videos';
            const transaction = this.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            
            const request = store.put(videoData);
            
            request.onerror = (event) => {
              console.error('비디오 저장 실패:', event);
              reject(new Error('비디오 저장 실패'));
            };
            
            request.onsuccess = () => {
              console.log('비디오가 성공적으로 저장되었습니다:', videoToStore.id);
              resolve();
            };
          } catch (error) {
            console.error('비디오 데이터 처리 중 오류:', error);
            reject(error);
          }
        };
        
        reader.onerror = (error) => {
          console.error('Blob 읽기 실패:', error);
          reject(new Error('비디오 Blob 데이터 읽기 실패'));
        };
      } else {
        // 이미 blobData가 있는 경우 직접 저장
        const storeName = isShort ? 'shorts' : 'videos';
        const transaction = this.db.transaction([storeName], 'readwrite');
        const store = transaction.objectStore(storeName);
        
        const request = store.put(videoToStore);
        
        request.onerror = (event) => {
          console.error('비디오 저장 실패:', event);
          reject(new Error('비디오 저장 실패'));
        };
        
        request.onsuccess = () => {
          console.log('비디오가 성공적으로 저장되었습니다:', videoToStore.id);
          resolve();
        };
      }
    });
  },
  
  // 모든 비디오 가져오기
  async getAllVideos(isShorts: boolean = false) {
    return new Promise<any[]>((resolve, reject) => {
      if (!this.db) {
        reject(new Error('데이터베이스가 초기화되지 않았습니다'));
        return;
      }
      
      const storeName = isShorts ? 'shorts' : 'videos';
      const transaction = this.db.transaction([storeName], 'readonly');
      const store = transaction.objectStore(storeName);
      
      const request = store.getAll();
      
      request.onerror = (event) => {
        console.error('비디오 가져오기 실패:', event);
        reject(new Error('비디오 가져오기 실패'));
      };
      
      request.onsuccess = () => {
        console.log(`${storeName} 스토어에서 ${request.result.length}개의 비디오를 불러왔습니다.`);
        resolve(request.result);
      };
    });
  },
  
  // 비디오 삭제
  async deleteVideo(id: string, isShort: boolean = false) {
    return new Promise<void>((resolve, reject) => {
      if (!this.db) {
        reject(new Error('데이터베이스가 초기화되지 않았습니다'));
        return;
      }
      
      const storeName = isShort ? 'shorts' : 'videos';
      const transaction = this.db.transaction([storeName], 'readwrite');
      const store = transaction.objectStore(storeName);
      
      const request = store.delete(id);
      
      request.onerror = (event) => {
        console.error('비디오 삭제 실패:', event);
        reject(new Error('비디오 삭제 실패'));
      };
      
      request.onsuccess = () => {
        console.log('비디오가 성공적으로 삭제되었습니다:', id);
        resolve();
      };
    });
  },
  
  // 시청 기록 저장
  async addToHistory(videoData: any) {
    return new Promise<void>((resolve, reject) => {
      if (!this.db) {
        reject(new Error('데이터베이스가 초기화되지 않았습니다'));
        return;
      }
      
      const transaction = this.db.transaction(['history'], 'readwrite');
      const store = transaction.objectStore('history');
      
      // Blob 데이터는 제외하고 메타데이터만 저장
      const historyEntry = {
        videoId: videoData.id,
        watchedAt: new Date(),
        video: { ...videoData }
      };
      
      // Blob 제거 (크기가 커서 저장하지 않음)
      if (historyEntry.video.blob) {
        delete historyEntry.video.blob;
      }
      
      const request = store.add(historyEntry);
      
      request.onerror = (event) => {
        console.error('시청 기록 저장 실패:', event);
        reject(new Error('시청 기록 저장 실패'));
      };
      
      request.onsuccess = () => {
        console.log('시청 기록이 저장되었습니다:', videoData.id);
        resolve();
      };
    });
  },
  
  // 시청 기록 가져오기
  async getHistory() {
    return new Promise<any[]>((resolve, reject) => {
      if (!this.db) {
        reject(new Error('데이터베이스가 초기화되지 않았습니다'));
        return;
      }
      
      const transaction = this.db.transaction(['history'], 'readonly');
      const store = transaction.objectStore('history');
      
      const request = store.getAll();
      
      request.onerror = (event) => {
        console.error('시청기록 가져오기 실패:', event);
        reject(new Error('시청기록 가져오기 실패'));
      };
      
      request.onsuccess = () => {
        console.log(`시청 기록 ${request.result.length}개를 불러왔습니다.`);
        resolve(request.result);
      };
    });
  },
  
  // 시청기록 삭제
  async removeFromHistory(id: number) {
    return new Promise<void>((resolve, reject) => {
      if (!this.db) {
        reject(new Error('데이터베이스가 초기화되지 않았습니다'));
        return;
      }
      
      try {
        // 'history' 스토어가 있는지 확인
        if (!Array.from(this.db.objectStoreNames).includes('history')) {
          console.error('history 저장소가 없습니다');
          reject(new Error('history 저장소가 없습니다'));
          return;
        }
        
        const transaction = this.db.transaction(['history'], 'readwrite');
        const store = transaction.objectStore('history');
        
        const request = store.delete(id);
        
        request.onerror = () => {
          reject(new Error('시청기록 삭제 실패'));
        };
        
        request.onsuccess = () => {
          resolve();
        };
      } catch (error) {
        console.error('removeFromHistory 실행 중 오류:', error);
        reject(error);
      }
    });
  },

  // 모든 시청기록 삭제
  async clearHistory() {
    return new Promise<void>((resolve, reject) => {
      if (!this.db) {
        reject(new Error('데이터베이스가 초기화되지 않았습니다'));
        return;
      }
      
      try {
        // 'history' 스토어가 있는지 확인
        if (!Array.from(this.db.objectStoreNames).includes('history')) {
          console.error('history 저장소가 없습니다');
          reject(new Error('history 저장소가 없습니다'));
          return;
        }
        
        const transaction = this.db.transaction(['history'], 'readwrite');
        const store = transaction.objectStore('history');
        
        const request = store.clear();
        
        request.onerror = () => {
          reject(new Error('시청기록 초기화 실패'));
        };
        
        request.onsuccess = () => {
          resolve();
        };
      } catch (error) {
        console.error('clearHistory 실행 중 오류:', error);
        reject(error);
      }
    });
  },

  // 비디오 좋아요 업데이트
  async updateVideoLike(id: string, liked: boolean, isShort: boolean = false) {
    return new Promise<void>((resolve, reject) => {
      if (!this.db) {
        reject(new Error('데이터베이스가 초기화되지 않았습니다'));
        return;
      }
      
      const storeName = isShort ? 'shorts' : 'videos';
      const transaction = this.db.transaction([storeName], 'readwrite');
      const store = transaction.objectStore(storeName);
      
      const request = store.get(id);
      
      request.onerror = (event) => {
        console.error('비디오 가져오기 실패:', event);
        reject(new Error('비디오 가져오기 실패'));
      };
      
      request.onsuccess = (event) => {
        const video = event.target.result;
        if (video) {
          const updatedVideo = { ...video };
          updatedVideo.liked = liked;
          updatedVideo.likes = liked ? (updatedVideo.likes || 0) + 1 : Math.max(0, (updatedVideo.likes || 0) - 1);
          updatedVideo.disliked = false;
          
          const putRequest = store.put(updatedVideo);
          
          putRequest.onerror = (event) => {
            console.error('비디오 저장 실패:', event);
            reject(new Error('비디오 저장 실패'));
          };
          
          putRequest.onsuccess = () => {
            console.log('비디오가 성공적으로 저장되었습니다:', updatedVideo.id);
            resolve();
          };
        } else {
          reject(new Error('비디오를 찾을 수 없습니다'));
        }
      };
    });
  },

  // 비디오 싫어요 업데이트
  async updateVideoDislike(id: string, disliked: boolean, isShort: boolean = false) {
    return new Promise<void>((resolve, reject) => {
      if (!this.db) {
        reject(new Error('데이터베이스가 초기화되지 않았습니다'));
        return;
      }
      
      const storeName = isShort ? 'shorts' : 'videos';
      const transaction = this.db.transaction([storeName], 'readwrite');
      const store = transaction.objectStore(storeName);
      
      const request = store.get(id);
      
      request.onerror = (event) => {
        console.error('비디오 가져오기 실패:', event);
        reject(new Error('비디오 가져오기 실패'));
      };
      
      request.onsuccess = (event) => {
        const video = event.target.result;
        if (video) {
          const updatedVideo = { ...video };
          updatedVideo.disliked = disliked;
          
          // 싫어요 수 업데이트
          if (disliked) {
            updatedVideo.dislikes = (updatedVideo.dislikes || 0) + 1;
          } else {
            updatedVideo.dislikes = Math.max(0, (updatedVideo.dislikes || 0) - 1);
          }
          
          // 좋아요가 활성화된 경우 비활성화
          if (disliked && updatedVideo.liked) {
            updatedVideo.liked = false;
            updatedVideo.likes = Math.max(0, (updatedVideo.likes || 0) - 1);
          }
          
          const putRequest = store.put(updatedVideo);
          
          putRequest.onerror = (event) => {
            console.error('비디오 저장 실패:', event);
            reject(new Error('비디오 저장 실패'));
          };
          
          putRequest.onsuccess = () => {
            console.log('비디오가 성공적으로 저장되었습니다:', updatedVideo.id);
            resolve();
          };
        } else {
          reject(new Error('비디오를 찾을 수 없습니다'));
        }
      };
    });
  },

  // 비디오 조회수 업데이트
  async updateVideoViews(id: string, isShort: boolean = false) {
    return new Promise<void>((resolve, reject) => {
      if (!this.db) {
        reject(new Error('데이터베이스가 초기화되지 않았습니다'));
        return;
      }
      
      const storeName = isShort ? 'shorts' : 'videos';
      const transaction = this.db.transaction([storeName], 'readwrite');
      const store = transaction.objectStore(storeName);
      
      const request = store.get(id);
      
      request.onerror = (event) => {
        console.error('비디오 가져오기 실패:', event);
        reject(new Error('비디오 가져오기 실패'));
      };
      
      request.onsuccess = (event) => {
        const video = event.target.result;
        if (video) {
          const updatedVideo = { ...video };
          // 조회수 증가
          updatedVideo.views = (updatedVideo.views || 0) + 1;
          
          const putRequest = store.put(updatedVideo);
          
          putRequest.onerror = (event) => {
            console.error('비디오 저장 실패:', event);
            reject(new Error('비디오 저장 실패'));
          };
          
          putRequest.onsuccess = () => {
            console.log('비디오 조회수 업데이트:', updatedVideo.id, updatedVideo.views);
            resolve();
          };
        } else {
          reject(new Error('비디오를 찾을 수 없습니다'));
        }
      };
    });
  },

  // 댓글 저장
  async addComment(videoId: string, comment: any) {
    return new Promise<number>((resolve, reject) => {
      try {
        if (!this.db) {
          console.error('데이터베이스가 초기화되지 않았습니다');
          reject(new Error('데이터베이스가 초기화되지 않았습니다'));
          return;
        }
        
        // comments 스토어가 있는지 확인
        if (!Array.from(this.db.objectStoreNames).includes('comments')) {
          console.error('comments 스토어가 존재하지 않습니다');
          
          // 임시 해결책: 메모리에 댓글 ID 생성 (실제로는 저장되지 않음)
          const tempId = Date.now();
          console.log('임시 댓글 ID 생성:', tempId);
          resolve(tempId);
          return;
        }
        
        // 댓글 데이터 정제
        const cleanComment = {
          videoId: videoId,
          text: comment.text || '',
          author: comment.author || '익명',
          createdAt: new Date(),
          likes: 0
        };
        
        console.log('댓글 저장 시도:', cleanComment);
        
        const transaction = this.db.transaction(['comments'], 'readwrite');
        
        transaction.onerror = (event) => {
          console.error('댓글 트랜잭션 오류:', event);
          reject(new Error('댓글 저장 트랜잭션 오류'));
        };
        
        const store = transaction.objectStore('comments');
        const request = store.add(cleanComment);
        
        request.onerror = (event) => {
          console.error('댓글 저장 실패:', event);
          
          // 임시 해결책: 메모리에 댓글 ID 생성 (실제로는 저장되지 않음)
          const tempId = Date.now();
          console.log('오류 발생 후 임시 댓글 ID 생성:', tempId);
          resolve(tempId);
        };
        
        request.onsuccess = (event) => {
          const commentId = (event.target as IDBRequest<number>).result;
          console.log('댓글이 성공적으로 저장되었습니다. ID:', commentId);
          resolve(commentId);
        };
      } catch (error) {
        console.error('addComment 함수 호출 중 예외 발생:', error);
        
        // 임시 해결책: 예외 발생 시 메모리에 댓글 ID 생성
        const tempId = Date.now();
        console.log('예외 발생 후 임시 댓글 ID 생성:', tempId);
        resolve(tempId);
      }
    });
  },
  
  // 비디오 ID로 댓글 가져오기
  async getCommentsByVideoId(videoId: string) {
    return new Promise<any[]>((resolve, reject) => {
      try {
        if (!this.db) {
          reject(new Error('데이터베이스가 초기화되지 않았습니다'));
          return;
        }
        
        // comments 스토어가 있는지 확인
        if (!Array.from(this.db.objectStoreNames).includes('comments')) {
          console.error('comments 스토어가 존재하지 않습니다');
          resolve([]); // 스토어가 없으면 빈 배열 반환
          return;
        }
        
        const transaction = this.db.transaction(['comments'], 'readonly');
        const store = transaction.objectStore('comments');
        
        // videoId 인덱스가 있는지 확인
        if (!store.indexNames.contains('videoId')) {
          console.error('videoId 인덱스가 존재하지 않습니다');
          
          // 모든 댓글을 가져와서 메모리에서 필터링
          const allCommentsRequest = store.getAll();
          
          allCommentsRequest.onerror = (event) => {
            console.error('댓글 가져오기 실패:', event);
            reject(new Error('댓글 가져오기 실패'));
          };
          
          allCommentsRequest.onsuccess = () => {
            const allComments = allCommentsRequest.result;
            const filteredComments = allComments.filter(comment => comment.videoId === videoId);
            console.log(`메모리 필터링으로 비디오 ID ${videoId}에 대한 댓글 ${filteredComments.length}개를 찾았습니다.`);
            resolve(filteredComments);
          };
          
          return;
        }
        
        const index = store.index('videoId');
        const request = index.getAll(videoId);
        
        request.onerror = (event) => {
          console.error('댓글 가져오기 실패:', event);
          reject(new Error('댓글 가져오기 실패'));
        };
        
        request.onsuccess = () => {
          console.log(`비디오 ID ${videoId}에 대한 댓글 ${request.result.length}개를 불러왔습니다.`);
          resolve(request.result);
        };
      } catch (error) {
        console.error('getCommentsByVideoId 함수 호출 중 예외 발생:', error);
        reject(error);
      }
    });
  },
  
  // 댓글 삭제
  async deleteComment(commentId: number) {
    return new Promise<void>((resolve, reject) => {
      if (!this.db) {
        reject(new Error('데이터베이스가 초기화되지 않았습니다'));
        return;
      }
      
      const transaction = this.db.transaction(['comments'], 'readwrite');
      const store = transaction.objectStore('comments');
      
      const request = store.delete(commentId);
      
      request.onerror = (event) => {
        console.error('댓글 삭제 실패:', event);
        reject(new Error('댓글 삭제 실패'));
      };
      
      request.onsuccess = () => {
        console.log('댓글이 성공적으로 삭제되었습니다:', commentId);
        resolve();
      };
    });
  },
  
  // 댓글 좋아요 업데이트
  async updateCommentLikes(commentId: number, liked: boolean) {
    return new Promise<void>((resolve, reject) => {
      if (!this.db) {
        reject(new Error('데이터베이스가 초기화되지 않았습니다'));
        return;
      }
      
      const transaction = this.db.transaction(['comments'], 'readwrite');
      const store = transaction.objectStore('comments');
      
      // 먼저 댓글 가져오기
      const getRequest = store.get(commentId);
      
      getRequest.onerror = (event) => {
        console.error('댓글 가져오기 실패:', event);
        reject(new Error('댓글 가져오기 실패'));
      };
      
      getRequest.onsuccess = () => {
        const comment = getRequest.result;
        if (!comment) {
          reject(new Error('댓글을 찾을 수 없습니다'));
          return;
        }
        
        // 좋아요 수 업데이트
        comment.likes = liked ? comment.likes + 1 : Math.max(0, comment.likes - 1);
        
        // 업데이트된 댓글 저장
        const updateRequest = store.put(comment);
        
        updateRequest.onerror = (event) => {
          console.error('댓글 좋아요 업데이트 실패:', event);
          reject(new Error('댓글 좋아요 업데이트 실패'));
        };
        
        updateRequest.onsuccess = () => {
          console.log('댓글 좋아요가 업데이트되었습니다:', commentId, liked);
          resolve();
        };
      };
    });
  }
};

const showCreateMenu = ref(false);
const showUploadModal = ref(false);
const fileInput = ref<HTMLInputElement | null>(null);
const selectedFile = ref<File | null>(null);
const uploading = ref(false);
const uploadProgress = ref(0);
const videos = ref<Array<{
  id: string,
  title: string,
  url: string | null,
  blob?: Blob,
  size: number,
  uploadDate: Date,
  isRefreshed: boolean,
  duration?: number,
  lastPosition?: number,
  liked?: boolean,
  likes?: number,
  disliked?: boolean,
  dislikes?: number
}>>([]);
const videoTitle = ref('');
const videoUrl = ref<string | null>(null);
const activeVideoMenu = ref<string | null>(null);
const notification = ref({
  show: false,
  type: 'success',
  title: '',
  message: '',
  timeout: null as number | null
});
const notificationList = ref<Array<{
  id?: string,
  title: string,
  message: string,
  type?: 'success' | 'error',
  time: Date,
  read?: boolean
}>>([]);
const showNotificationPanel = ref(false);
const searchQuery = ref('');
const isSearchActive = ref(false);
const showSearchResults = ref(false);
const showSearchPage = ref(false);
const currentView = ref('home');
const filteredVideos = ref<Array<any>>([]);
// shortsVideos ref 선언을 완전히 제거
// const shortsVideos = ref<Array<{
//   id: string,
//   title: string,
//   url: string | null,
//   blob?: Blob,
//   size: number,
//   uploadDate: Date,
//   isRefreshed: boolean,
//   duration: number
// }>>([]);

// 변수 추가
const activeMenuId = ref<string | null>(null);
const showDeleteModal = ref(false);
const deletingVideoId = ref<string | null>(null);
const dbInitialized = ref(false);

// 시청기록 관련 변수
const watchHistory = ref<Array<{
  id?: number,
  video: any,
  watchedAt: Date,
  isShort?: boolean
}>>([]);

// 비디오 상세 보기 관련 변수
const showVideoDetailModal = ref(false);
const selectedVideo = ref<any>({ id: '', title: '', url: null, uploadDate: new Date(), size: 0 });

// 시청 기록 비우기 관련 변수
const showClearHistoryModal = ref(false);
const startTime = ref<number | null>(null);
const comments = ref<Array<any>>([]);
const newComment = ref('');
const commentLoading = ref(false);
const isLiked = ref(false);

// IndexedDB 초기화 및 데이터 로드
onMounted(async () => {
  try {
    console.clear(); // 콘솔 초기화
    console.log('애플리케이션 초기화 시작...');
    
    // DB 초기화 플래그 비활성화로 시작
    dbInitialized.value = false;
    
    // IndexedDB 지원 확인
    if (!window.indexedDB) {
      console.error('이 브라우저는 IndexedDB를 지원하지 않습니다.');
      loadVideosFromLocalStorage();
      loadHistoryFromLocalStorage();
      loadNotificationsFromStorage();
      return;
    }

    // 기존 DB 삭제 시도 (선택사항)
    try {
      await new Promise<void>((resolve) => {
        const deleteRequest = indexedDB.deleteDatabase('videoDatabase');
        deleteRequest.onsuccess = () => {
          console.log('기존 데이터베이스 삭제 성공');
          resolve();
        };
        deleteRequest.onerror = () => {
          console.log('데이터베이스 삭제 시도 중 오류');
          resolve(); // 오류가 있어도 계속 진행
        };
      });
    } catch (e) {
      console.log('데이터베이스 삭제 오류 무시');
    }
    
    // DB 초기화 - 단순화된 방식
    try {
      await videoDB.init();
      dbInitialized.value = true;
      console.log('IndexedDB 초기화 성공!');
      
      // 데이터 로드
      await loadVideosFromIndexedDB();
      await loadHistoryFromIndexedDB();
    } catch (dbError) {
      console.error('DB 초기화 오류, 로컬 스토리지로 대체:', dbError);
      // DB 초기화 실패해도 사용자 경험 유지를 위해 로컬 데이터 로드
      loadVideosFromLocalStorage();
      loadHistoryFromLocalStorage();
      
      // 중요: 즉시 에러 알림 표시
      showNotification('error', 'DB 초기화 실패', '일부 기능이 제한될 수 있지만 계속 사용할 수 있습니다.');
    }
    
    // 알림 데이터 로드 - DB 상태와 무관
    loadNotificationsFromStorage();
    
    // 이벤트 리스너 설정
    document.addEventListener('click', (event) => {
      const target = event.target as HTMLElement;
      
      // 알림 패널 외부 클릭 시 닫기
      const notificationPanel = document.querySelector('.notification-panel');
      const notificationButton = document.querySelector('.notification-button');
      if (showNotificationPanel.value && 
          notificationPanel && 
          notificationButton && 
          !notificationPanel.contains(target) && 
          !notificationButton.contains(target)) {
        showNotificationPanel.value = false;
      }
      
      // 검색 결과 드롭다운 외부 클릭 시 닫기
      const searchForm = document.querySelector('.search-form');
      if (showSearchResults.value && 
          searchForm && 
          !searchForm.contains(target)) {
        showSearchResults.value = false;
      }
      
      // 메뉴 드롭다운 외부 클릭 시 닫기
      if (activeMenuId.value !== null && !event.composedPath().some(el => {
        const elem = el as HTMLElement;
        return elem.classList && (elem.classList.contains('shorts-menu-button') || elem.classList.contains('shorts-menu-dropdown'));
      })) {
        activeMenuId.value = null;
      }
      
      // 만들기 메뉴 외부 클릭 시 닫기
      if (showCreateMenu.value && !event.composedPath().some(el => {
        const elem = el as HTMLElement;
        return elem.classList && (elem.classList.contains('create-button') || elem.classList.contains('dropdown-menu'));
      })) {
        showCreateMenu.value = false;
      }
    });
  } catch (error) {
    console.error('애플리케이션 초기화 실패:', error);
    
    // 전체 초기화 실패해도 앱은 계속 작동하도록 함
    dbInitialized.value = false;
    loadVideosFromLocalStorage();
    loadHistoryFromLocalStorage();
    loadNotificationsFromStorage();
    
    // 초기화 실패 알림
    showNotification('error', '초기화 실패', '앱 초기화 중 오류가 발생했습니다. 일부 기능이 제한될 수 있습니다.');
  }
});

// IndexedDB에서 비디오 데이터 로드
const loadVideosFromIndexedDB = async () => {
  try {
    if (!dbInitialized.value) {
      console.log('데이터베이스가 초기화되지 않았습니다. 데이터 로드를 건너뜁니다.');
      loadVideosFromLocalStorage(); // 백업에서 로드 시도
      return;
    }
    
    console.log('IndexedDB에서 비디오 데이터 로드 시작...');
    
    // 일반 비디오 로드
    const videoData = await videoDB.getAllVideos(false);
    console.log('로드된 비디오 수:', videoData.length);
    
    // 쇼츠 비디오 로드
    const shortsData = await videoDB.getAllVideos(true);
    console.log('로드된 쇼츠 수:', shortsData.length);
    
    // 모든 비디오 데이터 합치기
    const allVideoData = [...videoData, ...shortsData];
    console.log('총 비디오 데이터 수:', allVideoData.length);
    
    if (allVideoData.length === 0) {
      console.log('저장된 비디오가 없습니다. 로컬 스토리지 확인 중...');
      loadVideosFromLocalStorage();
      return;
    }
    
    // 비디오 데이터 처리
    videos.value = await Promise.all(allVideoData.map(async (video) => {
      try {
        // ArrayBuffer를 Blob으로 변환하여 URL 생성
        let url = null;
        let blob = null;
        
        if (video.blobData) {
          try {
            blob = new Blob([video.blobData], { type: 'video/mp4' });
            url = URL.createObjectURL(blob);
            console.log('비디오 URL 생성 성공:', video.id);
          } catch (e) {
            console.error('Blob 생성 실패:', e);
          }
        }
        
        return {
          ...video,
          url,
          blob,
          uploadDate: new Date(video.uploadDate),
          isRefreshed: url === null, // URL이 생성되지 않은 경우만 새로고침 상태로 표시
          lastPosition: video.lastPosition || 0 // 저장된 재생 위치 유지
        };
      } catch (error) {
        console.error('비디오 처리 중 오류:', error);
        // 오류가 있어도 계속 진행하기 위해 기본 객체 반환
        return {
          ...video,
          url: null,
          blob: null,
          uploadDate: new Date(video.uploadDate),
          isRefreshed: true,
          lastPosition: video.lastPosition || 0 // 저장된 재생 위치 유지
        };
      }
    }));
    
    console.log('비디오 데이터 로드 완료:', videos.value.length, '개 비디오');
    
    // 메타데이터 백업
    saveVideosToLocalStorage();
    
    // 로드 후 Blob 데이터 체크
    const validVideos = videos.value.filter(v => v.url !== null);
    console.log('유효한 비디오 수 (URL 있음):', validVideos.length);
    
    // 시청 기록 로드
    try {
      await loadHistoryFromIndexedDB();
    } catch (historyError) {
      console.error('시청 기록 로드 실패:', historyError);
    }
  } catch (error) {
    console.error('IndexedDB에서 비디오 로드 실패:', error);
    // 오류 발생 시 로컬 스토리지에서 메타데이터만 로드
    loadVideosFromLocalStorage();
  }
};

// 시청기록 로드
const loadHistoryFromIndexedDB = async () => {
  try {
    if (!dbInitialized.value) {
      console.log('데이터베이스가 초기화되지 않았습니다. 시청기록 로드를 건너뜁니다.');
      loadHistoryFromLocalStorage();
      return;
    }
    
    console.log('IndexedDB에서 시청기록 로드 시작...');
    const historyData = await videoDB.getHistory();
    console.log('로드된 시청기록 수:', historyData.length);
    
    watchHistory.value = historyData.map(item => ({
      ...item,
      watchedAt: new Date(item.watchedAt),
      video: {
        ...item.video,
        uploadDate: new Date(item.video.uploadDate),
        isRefreshed: !item.video.url
      }
    })).sort((a, b) => b.watchedAt.getTime() - a.watchedAt.getTime()); // 최신순 정렬
    
    console.log('시청기록 로드 완료:', watchHistory.value.length);
  } catch (error) {
    console.error('시청기록 로드 실패:', error);
    loadHistoryFromLocalStorage();
  }
};

// 로컬 스토리지에서 시청기록 로드
const loadHistoryFromLocalStorage = () => {
  console.log('로컬 스토리지에서 시청기록 로드 시작...');
  const storedHistory = localStorage.getItem('watchHistory');
  if (storedHistory) {
    try {
      const parsedHistory = JSON.parse(storedHistory);
      watchHistory.value = parsedHistory.map((item: any) => ({
        ...item,
        watchedAt: new Date(item.watchedAt),
        video: {
          ...item.video,
          uploadDate: new Date(item.video.uploadDate),
          url: null, // 새로고침 후에는 URL을 null로 설정
          isRefreshed: true
        }
      }));
      console.log('로컬 스토리지에서 시청기록 로드 완료:', watchHistory.value.length);
    } catch (error) {
      console.error('시청기록 파싱 실패:', error);
      watchHistory.value = [];
    }
  } else {
    console.log('로컬 스토리지에 저장된 시청기록이 없습니다.');
    watchHistory.value = [];
  }
};

// 시청기록 로컬 스토리지에 저장
const saveHistoryToLocalStorage = () => {
  try {
    const historyToSave = watchHistory.value.map(item => {
      const { video, ...rest } = item;
      const { url, blob, isRefreshed, ...videoRest } = video;
      return {
        ...rest,
        video: videoRest
      };
    });
    
    localStorage.setItem('watchHistory', JSON.stringify(historyToSave));
    console.log('시청기록이 로컬 스토리지에 백업되었습니다.');
  } catch (error) {
    console.error('시청기록 로컬 스토리지 저장 실패:', error);
  }
};

// 비디오 상세보기
const openVideoDetail = async (video: any) => {
  console.log('openVideoDetail 함수 호출됨:', video.title);
  
  // 이전 재생 시간을 가져옴 (없으면 0)
  const lastPosition = video.lastPosition || 0;
  
  // 비디오 데이터 복사
  selectedVideo.value = { ...video };
  
  // 좋아요 상태 초기화 
  isLiked.value = video.liked || false;
  
  // 모달 대신 새로운 뷰로 전환
  currentView.value = 'videoDetail';
  
  // 조회수 증가 - 데이터베이스 초기화 상태 확인 추가
  if (video && video.id) {
    try {
      if (dbInitialized.value) {
        await videoDB.updateVideoViews(video.id);
      } else {
        console.warn('데이터베이스가 초기화되지 않아 조회수를 업데이트할 수 없습니다');
      }
      
      // 메모리에서 비디오 객체 업데이트
      const index = videos.value.findIndex(v => v.id === video.id);
      if (index !== -1) {
        // 비디오 객체 복사
        const updatedVideo = { ...videos.value[index] };
        // 조회수 증가
        updatedVideo.views = (updatedVideo.views || 0) + 1;
        // 업데이트된 비디오 객체로 교체
        videos.value[index] = updatedVideo;
        // 선택된 비디오도 업데이트
        selectedVideo.value = updatedVideo;
      }
    } catch (error) {
      console.error('조회수 업데이트 실패:', error);
      // 오류가 발생해도 메모리에서는 조회수 증가
      const index = videos.value.findIndex(v => v.id === video.id);
      if (index !== -1) {
        const updatedVideo = { ...videos.value[index] };
        updatedVideo.views = (updatedVideo.views || 0) + 1;
        videos.value[index] = updatedVideo;
        selectedVideo.value = updatedVideo;
      }
    }
  }
  
  // 시청기록에 추가
  addToHistory(video);
  
  // 댓글 로드
  await loadComments();
  
  // 이전 재생 위치가 있으면 다음 렌더링 후 해당 위치로 설정
  if (lastPosition > 0) {
    nextTick(() => {
      const videoPlayer = document.querySelector('.video-detail-container video') as HTMLVideoElement;
      if (videoPlayer) {
        console.log('이전 재생 위치로 설정:', lastPosition);
        videoPlayer.currentTime = lastPosition;
      }
    });
  }
  
  // 동영상 재생 시작 시점 기록
  if (video && !video.isShort) {
    startTime.value = Date.now();
  }
};

// 비디오 상세보기 닫기
const closeVideoDetail = () => {
  // 현재 재생 위치 저장
  try {
    const videoPlayer = document.querySelector('.video-detail-container video') as HTMLVideoElement;
    if (videoPlayer && selectedVideo.value && selectedVideo.value.id) {
      const currentTime = videoPlayer.currentTime;
      
      // 비디오 객체에 마지막 재생 위치 저장
      const index = videos.value.findIndex(v => v.id === selectedVideo.value.id);
      if (index !== -1) {
        videos.value[index].lastPosition = currentTime;
        console.log('비디오 재생 위치 저장:', videos.value[index].title, currentTime);
      }
    }
  } catch (error) {
    console.error('재생 위치 저장 중 오류:', error);
  }
  
  // 홈 화면으로 돌아가기
  currentView.value = 'home';
};

// 시청기록에 추가
const addToHistory = async (video: any) => {
  try {
    // 비디오가 이미 기록되어 있더라도 항상 새 기록 추가 (같은 비디오를 여러번 볼 수 있기 때문)
    if (dbInitialized.value) {
      await videoDB.addToHistory(video);
    }
    
    // 메모리에 추가
    const historyItem = {
      video,
      watchedAt: new Date(),
      isShort: video.duration <= 50
    };
    
    watchHistory.value.unshift(historyItem);
    
    // 로컬 스토리지 백업
    saveHistoryToLocalStorage();
    
    console.log('시청기록에 추가됨:', video.title);
  } catch (error) {
    console.error('시청기록 추가 실패:', error);
  }
};

// 시청기록에서 제거
const removeFromHistory = async (id: number | undefined) => {
  if (id === undefined) return;
  
  try {
    const index = watchHistory.value.findIndex(h => h.id === id);
    if (index !== -1) {
      // IndexedDB에서 삭제
      if (dbInitialized.value) {
        await videoDB.removeFromHistory(id);
      }
      
      // 메모리에서 삭제
      watchHistory.value.splice(index, 1);
      
      // 로컬 스토리지 백업
      saveHistoryToLocalStorage();
      
      showNotification('success', '기록 삭제', '시청기록에서 삭제되었습니다.');
    }
  } catch (error) {
    console.error('시청기록 삭제 실패:', error);
    showNotification('error', '삭제 실패', '시청기록 삭제 중 오류가 발생했습니다.');
  }
};

// 비디오 카드 클릭 이벤트 처리를 위한 함수 수정
const handleVideoClick = (video: any) => {
  openVideoDetail(video);
};

// 시청 기록 비우기 확인 모달 열기
const confirmClearHistory = () => {
  showClearHistoryModal.value = true;
};

// 시청 기록 비우기 취소
const cancelClearHistory = () => {
  showClearHistoryModal.value = false;
};

// 모든 시청 기록 삭제
const clearAllHistory = async () => {
  try {
    if (dbInitialized.value) {
      await videoDB.clearHistory();
    }
    
    watchHistory.value = [];
    saveHistoryToLocalStorage();
    
    showNotification('success', '시청 기록 삭제', '모든 시청 기록이 삭제되었습니다.');
    showClearHistoryModal.value = false;
  } catch (error) {
    console.error('시청 기록 삭제 실패:', error);
    showNotification('error', '삭제 실패', '시청 기록 삭제 중 오류가 발생했습니다.');
  }
};

// 비디오 상세 모달에서 비디오 변경 함수
const changeVideo = (video: any) => {
  selectedVideo.value = video;
  
  // 이전 재생 시간을 가져옴 (없으면 0)
  const lastPosition = video.lastPosition || 0;
  
  // 시청기록에 추가
  addToHistory(video);
  
  // 이전 재생 위치가 있으면 다음 렌더링 후 해당 위치로 설정
  if (lastPosition > 0) {
    nextTick(() => {
      const videoPlayer = document.querySelector('.video-player-container video') as HTMLVideoElement;
      if (videoPlayer) {
        console.log('이전 재생 위치로 설정:', lastPosition);
        videoPlayer.currentTime = lastPosition;
      }
    });
  }
};

// 비디오 상세 모달에서 비디오 진행 상태 업데이트 함수
const updateVideoProgress = (event: Event) => {
  const videoElement = event.target as HTMLVideoElement;
  const currentTime = videoElement.currentTime;
  
  // 현재 선택된 비디오의 인덱스 찾기
  const index = videos.value.findIndex(v => v.id === selectedVideo.value.id);
  if (index !== -1) {
    // 5초마다 저장 (너무 자주 저장하지 않기 위해)
    if (Math.floor(currentTime) % 5 === 0) {
      videos.value[index].lastPosition = currentTime;
    }
  }
};

// 비디오 상세 모달에서 비디오 종료 처리 함수
const handleVideoEnded = () => {
  console.log('handleVideoEnded 함수 호출됨');
  
  // 비디오가 끝까지 재생되면 재생 위치를 0으로 초기화
  if (selectedVideo.value) {
    const index = videos.value.findIndex(v => v.id === selectedVideo.value.id);
    if (index !== -1) {
      videos.value[index].lastPosition = 0;
      console.log('비디오 재생 완료, 위치 초기화:', videos.value[index].title);
      
      // 로컬 스토리지 업데이트
      saveVideosToLocalStorage();
    }
  }
  
  // 여기에 추천 비디오 자동 재생 등의 로직을 추가할 수 있습니다.
};

// 비디오 상세 모달에서 추천 비디오 설정 함수
const recommendedVideos = ref<any[]>([]);

// 추천 비디오 설정 로직을 구현해야 합니다.

// 계산된 속성들
// ... existing code ...

// 쇼츠 비디오 (50초 이하의 비디오)
const shortsVideos = computed(() => {
  return videos.value.filter(video => {
    return video.duration && video.duration <= 50;
  });
});

// 일반 비디오 (50초 초과 비디오)
const normalVideos = computed(() => {
  return videos.value.filter(video => {
    return !video.duration || video.duration > 50;
  });
});

// 전체 비디오 (일반 + 쇼츠)
const allVideos = computed(() => {
  return videos.value;
});

// ... existing code ...

// 비디오 파일 처리 함수 (Blob 데이터 포함)
const processVideoFile = async (file: File) => {
  return new Promise<{ url: string, duration: number, blob: Blob }>((resolve, reject) => {
    try {
      const video = document.createElement('video');
      const url = URL.createObjectURL(file);
      
      video.onloadedmetadata = () => {
        const duration = video.duration; // 비디오 길이 (초)
        console.log('비디오 메타데이터 추출 완료:', duration, '초');
        resolve({ url, duration, blob: file });
      };
      
      video.onerror = (e) => {
        console.error('비디오 메타데이터 로드 실패:', e);
        reject(new Error('비디오 메타데이터 로드 실패'));
      };
      
      video.src = url;
    } catch (error) {
      console.error('processVideoFile 에러:', error);
      reject(error);
    }
  });
};

// 동영상 업로드 함수
const uploadVideo = async () => {
  if (!selectedFile.value) {
    console.error('선택된 파일이 없습니다.');
    return;
  }
  
  try {
    uploading.value = true;
    console.log('동영상 업로드 시작:', selectedFile.value.name);
    
    // 파일 처리 및 메타데이터 추출
    const { url, duration, blob } = await processVideoFile(selectedFile.value);
    const fileSize = selectedFile.value.size;
    
    // 제목이 비어있거나 UUID 형식인 경우 파일 이름을 사용
    let title = videoTitle.value.trim();
    
    // UUID 패턴 확인 (예: 0b078f0a-e210-4513-9f66-f29821b7fc5d)
    const uuidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    
    if (!title || uuidPattern.test(title)) {
      title = selectedFile.value.name.split('.')[0] || '제목 없음';
    }
    
    const id = `video_${Date.now()}`;
    console.log('생성된 동영상 ID:', id);
    
    const newVideo = {
      id,
      title,
      url,
      blob,
      size: fileSize,
      uploadDate: new Date(),
      isRefreshed: false,
      duration
    };
    
    // 업로드 진행 시각화
    let progress = 0;
    const progressInterval = setInterval(() => {
      progress += 5;
      uploadProgress.value = Math.min(progress, 99);
      
      if (progress >= 100) {
        clearInterval(progressInterval);
      }
    }, 100);
    
    // 쇼츠 여부 확인 (50초 이하)
    const isShort = duration <= 50;
    console.log('비디오 타입:', isShort ? '쇼츠' : '일반 동영상');
    
    // IndexedDB에 저장
    if (dbInitialized.value) {
      try {
        console.log('IndexedDB에 동영상 저장 시작');
        await videoDB.saveVideo(newVideo, isShort);
        console.log('IndexedDB에 동영상 저장 성공');
      } catch (saveError) {
        console.error('IndexedDB 저장 실패, 로컬 스토리지 백업:', saveError);
        // IndexedDB 저장 실패 시 로컬 스토리지에 메타데이터 백업
        saveVideosToLocalStorage();
      }
    } else {
      console.warn('데이터베이스가 초기화되지 않음, 로컬 스토리지에 저장');
      saveVideosToLocalStorage();
    }
    
    // 메모리에 추가
    videos.value.unshift(newVideo);
    console.log('동영상이 메모리에 추가됨');
    
    // 알림 표시
    if (isShort) {
      addNotification(`${title}`, '쇼츠가 업로드 되었습니다.');
    } else {
      addNotification(`${title}`, '동영상이 업로드 되었습니다.');
    }
    
    // 업로드 완료 처리
    uploadProgress.value = 100;
    setTimeout(() => {
      closeModal();
    }, 500);
    
    videoTitle.value = '';
    selectedFile.value = null;
    console.log('업로드 완료');
  } catch (error) {
    console.error('동영상 업로드 중 오류:', error);
    addNotification('업로드 실패', '동영상 처리 중 오류가 발생했습니다.');
  } finally {
    uploading.value = false;
  }
};

// 로컬 스토리지에서 동영상 정보 불러오는 함수 (IndexedDB 사용 불가 시 대체)
const loadVideosFromLocalStorage = () => {
  const storedVideos = localStorage.getItem('uploadedVideos');
  if (storedVideos) {
    try {
      const parsedVideos = JSON.parse(storedVideos);
      videos.value = parsedVideos.map((video: any) => ({
        ...video,
        uploadDate: new Date(video.uploadDate),
        url: null, // 새로고침 후에는 URL을 null로 설정
        isRefreshed: true,
        lastPosition: video.lastPosition || 0  // 저장된 재생 위치도 불러옴
      }));
      console.log('로컬 스토리지에서 동영상 메타데이터 로드 완료:', videos.value.length);
    } catch (e) {
      console.error('로컬 스토리지에서 동영상 정보 파싱 실패', e);
    }
  }
};

// 메타데이터 저장 (IndexedDB 오류 시 대체)
const saveVideosToLocalStorage = () => {
  try {
    // URL 정보는 제외하고 저장 (새로고침 후 사용할 수 없기 때문)
    const videosToSave = videos.value.map(video => {
      const { url, blob, isRefreshed, ...rest } = video;
      return {
        ...rest,
        // lastPosition도 저장
        lastPosition: video.lastPosition || 0
      };
    });
    
    localStorage.setItem('uploadedVideos', JSON.stringify(videosToSave));
    console.log('동영상 메타데이터가 로컬 스토리지에 백업되었습니다.');
  } catch (error) {
    console.error('로컬 스토리지 저장 실패:', error);
  }
};

// 검색 결과에 표시할 비디오
const displayVideos = computed(() => {
  if (isSearchActive.value && searchQuery.value.trim() !== '') {
    return filteredVideos.value;
  }
  // 홈 화면에는 일반 동영상만 표시 (쇼츠는 제외)
  return normalVideos.value;
});

const toggleCreateMenu = () => {
  showCreateMenu.value = !showCreateMenu.value;
};

// 동영상 업로드 모달 열기
const openUploadModal = () => {
  console.log('openUploadModal 함수 호출됨');
  showUploadModal.value = true;
  showCreateMenu.value = false;
};

// 알림 데이터 로컬 스토리지에서 로드
const loadNotificationsFromStorage = () => {
  try {
    const storedNotifications = localStorage.getItem('notifications');
    if (storedNotifications) {
      const parsedNotifications = JSON.parse(storedNotifications);
      notificationList.value = parsedNotifications.map((notification: any) => ({
        ...notification,
        time: new Date(notification.time)
      }));
      console.log('알림 데이터 로드 완료:', notificationList.value.length);
    }
  } catch (error) {
    console.error('알림 데이터 로드 실패:', error);
    notificationList.value = [];
  }
};

// 알림 데이터 로컬 스토리지에 저장
const saveNotificationsToStorage = () => {
  try {
    localStorage.setItem('notifications', JSON.stringify(notificationList.value));
  } catch (error) {
    console.error('알림 데이터 저장 실패:', error);
  }
};

// 알림 추가
const addNotification = (title: string, message: string, type: 'success' | 'error' = 'success') => {
  const newNotification = {
    id: `notification_${Date.now()}`,
    title,
    message,
    type,
    time: new Date(),
    read: false
  };
  
  notificationList.value.unshift(newNotification);
  saveNotificationsToStorage();
  
  showNotification(type, title, message);
};

// 모든 알림 삭제
const clearAllNotifications = () => {
  notificationList.value = [];
  saveNotificationsToStorage();
  showNotificationPanel.value = false;
};

// 알림 시간 형식화
const formatNotificationTime = (date: Date) => {
  return formatDate(date);
};

// 모달 닫기
const closeModal = () => {
  console.log('closeModal 함수 호출됨');
  showUploadModal.value = false;
  selectedFile.value = null;
  uploading.value = false;
  uploadProgress.value = 0;
  videoTitle.value = '';
  videoUrl.value = null;
};

// 파일 입력 트리거
const triggerFileInput = () => {
  console.log('triggerFileInput 함수 호출됨');
  if (fileInput.value) {
    fileInput.value.click();
  } else {
    console.error('fileInput ref가 null입니다');
  }
};

// 파일 선택 변경 이벤트 처리
const handleFileChange = (event: Event) => {
  console.log('handleFileChange 함수 호출됨');
  const input = event.target as HTMLInputElement;
  if (input.files && input.files.length > 0) {
    selectedFile.value = input.files[0];
    videoTitle.value = selectedFile.value.name.split('.')[0] || '제목 없음';
    console.log('파일 선택됨:', selectedFile.value.name);
  }
};

// 파일 드래그 앤 드롭 처리
const handleFileDrop = (event: DragEvent) => {
  console.log('handleFileDrop 함수 호출됨');
  if (event.dataTransfer?.files && event.dataTransfer.files.length > 0) {
    selectedFile.value = event.dataTransfer.files[0];
    videoTitle.value = selectedFile.value.name.split('.')[0] || '제목 없음';
    console.log('파일 드롭됨:', selectedFile.value.name);
  }
};

// 파일 크기 포맷
const formatFileSize = (bytes: number): string => {
  if (bytes === 0) return '0 Bytes';
  
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(1024));
  
  return parseFloat((bytes / Math.pow(1024, i)).toFixed(2)) + ' ' + sizes[i];
};

// 날짜 포맷
const formatDate = (date: Date): string => {
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffSec = Math.floor(diffMs / 1000);
  const diffMin = Math.floor(diffSec / 60);
  const diffHour = Math.floor(diffMin / 60);
  const diffDay = Math.floor(diffHour / 24);
  
  if (diffSec < 60) return '방금 전';
  if (diffMin < 60) return `${diffMin}분 전`;
  if (diffHour < 24) return `${diffHour}시간 전`;
  if (diffDay < 30) return `${diffDay}일 전`;
  
  // 30일 이상이면 날짜 형식으로 표시
  return new Intl.DateTimeFormat('ko-KR', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  }).format(date);
};

// 동영상 길이 포맷
const formatDuration = (seconds: number): string => {
  if (!seconds) return '';
  
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = Math.floor(seconds % 60);
  
  if (minutes === 0) {
    return `${remainingSeconds}초`;
  }
  
  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
};

// 알림 표시 함수
const showNotification = (type: 'success' | 'error', title: string, message: string, duration: number = 4000) => {
  console.log('showNotification 함수 호출됨:', type, title, message);
  
  // 기존 타이머가 있으면 제거
  if (notification.value.timeout) {
    clearTimeout(notification.value.timeout);
  }
  
  // 알림 정보 설정
  notification.value = {
    show: true,
    type,
    title,
    message,
    timeout: null
  };
  
  // 지정된 시간 후 알림 닫기
  notification.value.timeout = setTimeout(() => {
    closeNotification();
  }, duration) as unknown as number;
};

// 알림 닫기
const closeNotification = () => {
  notification.value.show = false;
  if (notification.value.timeout) {
    clearTimeout(notification.value.timeout);
    notification.value.timeout = null;
  }
};

// 쇼츠 메뉴 열기
const openShortsMenu = (videoId: string) => {
  console.log('openShortsMenu 함수 호출됨:', videoId);
  
  if (activeMenuId.value === videoId) {
    activeMenuId.value = null; // 이미 열려있으면 닫기
  } else {
    activeMenuId.value = videoId; // 새로 열기
  }
};

// 쇼츠 삭제 확인 모달 열기
const confirmDeleteShorts = (videoId: string) => {
  console.log('confirmDeleteShorts 함수 호출됨:', videoId);
  
  deletingVideoId.value = videoId;
  showDeleteModal.value = true;
  activeMenuId.value = null; // 메뉴 닫기
};

// 삭제 취소
const cancelDelete = () => {
  console.log('cancelDelete 함수 호출됨');
  
  showDeleteModal.value = false;
  deletingVideoId.value = null;
};

// 삭제 확인
const confirmDelete = async () => {
  console.log('confirmDelete 함수 호출됨');
  
  if (deletingVideoId.value) {
    await deleteVideo(deletingVideoId.value, true); // 쇼츠 삭제
  }
  
  showDeleteModal.value = false;
  deletingVideoId.value = null;
};

// 비디오 삭제
const deleteVideo = async (videoId: string, isShort: boolean = false) => {
  console.log('deleteVideo 함수 호출됨:', videoId, isShort);
  
  try {
    // IndexedDB에서 삭제
    if (dbInitialized.value) {
      await videoDB.deleteVideo(videoId, isShort);
    }
    
    // 메모리에서 삭제
    const index = videos.value.findIndex(v => v.id === videoId);
    if (index !== -1) {
      // URL이 있으면 해제
      if (videos.value[index].url) {
        URL.revokeObjectURL(videos.value[index].url);
      }
      
      // 목록에서 제거
      videos.value.splice(index, 1);
      showNotification('success', '삭제 완료', isShort ? '쇼츠가 삭제되었습니다.' : '동영상이 삭제되었습니다.');
      
      // 로컬 스토리지 업데이트
      saveVideosToLocalStorage();
    }
  } catch (error) {
    console.error('비디오 삭제 중 오류:', error);
    showNotification('error', '삭제 실패', '동영상 삭제 중 오류가 발생했습니다.');
  }
};

// 검색 실행
const searchVideos = () => {
  console.log('searchVideos 함수 호출됨');
  
  if (searchQuery.value.trim()) {
    isSearchActive.value = true;
    
    // 대소문자 구분없이 검색어 포함 여부로 필터링
    const query = searchQuery.value.trim().toLowerCase();
    filteredVideos.value = videos.value.filter(video => 
      video.title.toLowerCase().includes(query)
    );
    
    showSearchResults.value = false; // 검색 결과 드롭다운 닫기
    console.log('검색 결과:', filteredVideos.value.length);
  } else {
    clearSearch();
  }
};

// 검색 초기화
const clearSearch = () => {
  console.log('clearSearch 함수 호출됨');
  
  searchQuery.value = '';
  isSearchActive.value = false;
  showSearchResults.value = false;
  filteredVideos.value = [];
};

// 검색 페이지 열기
const openSearchPage = () => {
  console.log('openSearchPage 함수 호출됨');
  
  showSearchPage.value = true;
};

// 검색 페이지 닫기
const closeSearchPage = () => {
  console.log('closeSearchPage 함수 호출됨');
  
  showSearchPage.value = false;
};

// 검색 결과 선택
const selectSearchResult = (video: any) => {
  console.log('selectSearchResult 함수 호출됨:', video.title);
  
  openVideoDetail(video);
  showSearchResults.value = false;
  showSearchPage.value = false;
};

// 현재 화면 설정
const setCurrentView = (view: string) => {
  console.log('setCurrentView 함수 호출됨:', view);
  
  currentView.value = view;
};

// 추천 비디오 목록 계산 속성 추가
const filteredRecommendedVideos = computed(() => {
  if (!selectedVideo.value || !selectedVideo.value.id) {
    return [];
  }
  return videos.value.filter(video => 
    video && video.id && video.id !== selectedVideo.value.id
  );
});

// 좋아요 토글 함수
const toggleLike = async () => {
  if (!selectedVideo.value || !selectedVideo.value.id) return;
  
  try {
    isLiked.value = !isLiked.value;
    
    // 메모리에서 비디오 객체 업데이트
    const index = videos.value.findIndex(v => v.id === selectedVideo.value.id);
    if (index !== -1) {
      // 비디오 객체 복사
      const updatedVideo = { ...videos.value[index] };
      // 좋아요 수 업데이트
      updatedVideo.likes = (updatedVideo.likes || 0) + (isLiked.value ? 1 : -1);
      // 최소 0으로 설정
      updatedVideo.likes = Math.max(0, updatedVideo.likes);
      // 업데이트된 비디오 객체로 교체
      videos.value[index] = updatedVideo;
      // 선택된 비디오도 업데이트
      selectedVideo.value = updatedVideo;
    }
  } catch (error) {
    console.error('좋아요 상태 업데이트 실패:', error);
    showNotification('error', '업데이트 실패', '좋아요 상태를 업데이트하는 중 오류가 발생했습니다.');
  }
};

// 싫어요 토글 함수
const toggleDislike = async (video: any) => {
  try {
    // 이미 싫어요 상태이면 취소, 아니면 활성화
    const newDislikedState = !video.disliked;
    
    // 메모리에서 처리
    const index = videos.value.findIndex(v => v.id === video.id);
    if (index !== -1) {
      // 비디오 객체 복사
      const updatedVideo = { ...videos.value[index] };
      
      // 싫어요 상태 업데이트
      updatedVideo.disliked = newDislikedState;
      
      // 싫어요 수 업데이트
      if (newDislikedState) {
        updatedVideo.dislikes = (updatedVideo.dislikes || 0) + 1;
      } else {
        updatedVideo.dislikes = Math.max(0, (updatedVideo.dislikes || 0) - 1);
      }
      
      // 좋아요가 active 상태면 해제하고 좋아요 수도 감소
      if (newDislikedState && updatedVideo.liked) {
        updatedVideo.liked = false;
        updatedVideo.likes = Math.max(0, (updatedVideo.likes || 0) - 1);
      }
      
      // 비디오 객체 업데이트
      videos.value[index] = updatedVideo;
      
      // 현재 선택된 비디오가 이 비디오이면 선택된 비디오도 업데이트
      if (selectedVideo.value.id === video.id) {
        selectedVideo.value = { ...updatedVideo };
      }
      
      // IndexedDB에 저장
      if (dbInitialized.value) {
        const isShort = video.duration && video.duration <= 50;
        await videoDB.updateVideoDislike(video.id, newDislikedState, isShort);
      }
      
      // 로컬 스토리지 백업
      saveVideosToLocalStorage();
      
      console.log(`비디오 ${newDislikedState ? '싫어요' : '싫어요 취소'}:`, video.title);
    }
  } catch (error) {
    console.error('싫어요 상태 업데이트 실패:', error);
    showNotification('error', '업데이트 실패', '싫어요 상태를 업데이트하는 중 오류가 발생했습니다.');
  }
};

// 댓글 로드 함수 수정
const loadComments = async () => {
  if (!selectedVideo.value || !selectedVideo.value.id) return;
  
  commentLoading.value = true;
  try {
    if (dbInitialized.value) {
      const videoComments = await videoDB.getCommentsByVideoId(selectedVideo.value.id);
      comments.value = videoComments.sort((a, b) => 
        new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
      );
    } else {
      console.warn('데이터베이스가 초기화되지 않아 댓글을 로드할 수 없습니다');
      comments.value = []; // 빈 배열로 초기화
    }
  } catch (error) {
    console.error('댓글 로드 실패:', error);
    comments.value = []; // 오류 발생 시 빈 배열로 초기화
    showNotification('error', '댓글 로드 실패', '댓글을 불러오는 중 오류가 발생했습니다.');
  } finally {
    commentLoading.value = false;
  }
};

// 댓글 추가 함수 수정
const addComment = async () => {
  if (!newComment.value.trim()) {
    return;
  }
  
  if (!selectedVideo.value || !selectedVideo.value.id) {
    console.error('댓글 추가 실패: 선택된 비디오가 없습니다.');
    showNotification('error', '댓글 추가 실패', '비디오 정보를 찾을 수 없습니다.');
    return;
  }
  
  try {
    console.log('댓글 추가 시작...');
    
    // 댓글 데이터 객체 생성
    const commentData = {
      text: newComment.value.trim(),
      author: '사용자', // 사용자 정보가 있다면 변경
      createdAt: new Date()
    };
    
    let commentId;
    
    // DB 초기화 상태에 따라 다르게 처리
    if (dbInitialized.value) {
      // 댓글 추가 API 호출
      commentId = await videoDB.addComment(selectedVideo.value.id, commentData);
      console.log('DB에 댓글 추가됨, ID:', commentId);
    } else {
      // DB가 초기화되지 않은 경우 임시 ID 생성
      commentId = Date.now();
      console.log('임시 댓글 ID 생성:', commentId);
      // 사용자에게 알림
      showNotification('warning', '임시 저장됨', '데이터베이스가 초기화되지 않아 댓글이 임시로 표시됩니다. 새로고침 시 사라질 수 있습니다.');
    }
    
    // 성공하면 메모리에 추가 (DB 상태와 무관하게 UI 업데이트)
    comments.value.unshift({
      id: commentId,
      videoId: selectedVideo.value.id,
      text: commentData.text,
      author: commentData.author,
      createdAt: commentData.createdAt,
      likes: 0
    });
    
    // 입력 필드 초기화
    newComment.value = '';
    
    // 성공 메시지 표시
    showNotification('success', '댓글 추가', '댓글이 성공적으로 추가되었습니다.');
  } catch (error) {
    console.error('댓글 추가 실패:', error);
    
    // 오류가 발생해도 UI에 댓글 추가 (UX 향상)
    const tempId = Date.now();
    comments.value.unshift({
      id: tempId,
      videoId: selectedVideo.value.id,
      text: newComment.value.trim(),
      author: '사용자',
      createdAt: new Date(),
      likes: 0,
      isTemporary: true // 임시 댓글 표시
    });
    
    // 입력 필드 초기화
    newComment.value = '';
    
    // 알림 표시
    showNotification('warning', '댓글 추가됨', '오류가 발생했지만 댓글이 화면에 표시됩니다. 새로고침 시 사라질 수 있습니다.');
  }
};

// 댓글 삭제 함수 수정
const deleteComment = async (commentId: number) => {
  try {
    if (!dbInitialized.value) {
      showNotification('error', '댓글 삭제 실패', '데이터베이스가 초기화되지 않았습니다.');
      return;
    }
    
    await videoDB.deleteComment(commentId);
    
    // 메모리에서 삭제
    const index = comments.value.findIndex(c => c.id === commentId);
    if (index !== -1) {
      comments.value.splice(index, 1);
    }
    
    showNotification('success', '댓글 삭제', '댓글이 성공적으로 삭제되었습니다.');
  } catch (error) {
    console.error('댓글 삭제 실패:', error);
    showNotification('error', '댓글 삭제 실패', '댓글을 삭제하는 중 오류가 발생했습니다.');
  }
};

// 댓글 좋아요 함수 수정
const likeComment = async (commentId: number) => {
  try {
    // 메모리에서 먼저 업데이트 (즉각적인 UI 응답)
    const comment = comments.value.find(c => c.id === commentId);
    if (comment) {
      comment.likes = (comment.likes || 0) + 1;
    }
    
    // DB가 초기화된 경우에만 저장 시도
    if (dbInitialized.value) {
      try {
        await videoDB.updateCommentLikes(commentId, true);
        console.log('댓글 좋아요 DB 업데이트 성공:', commentId);
      } catch (dbError) {
        console.error('좋아요 DB 업데이트 실패:', dbError);
        // UI는 이미 업데이트되었으므로 사용자에게 오류 메시지는 표시하지 않음
      }
    } else {
      console.log('DB가 초기화되지 않았지만 UI는 업데이트됨');
    }
  } catch (error) {
    console.error('댓글 좋아요 업데이트 실패:', error);
    // 중요하지 않은 오류라 사용자에게 알리지 않음
  }
};

// ... existing code ...
          <input 
            type="text" 
            placeholder="검색" 
            class="search-input" 
            v-model="searchQuery" 
            @focus="handleSearchFocus"
            readonly
          >
// ... existing code ...

// 검색 입력 필드 포커스 처리
const handleSearchFocus = (event: FocusEvent) => {
  // 개발자 도구(F12)로 인한 포커스인지 확인
  // 사용자가 직접 클릭한 경우에만 검색 페이지 열기
  if (event.isTrusted && !window.lastKeyWasF12) {
    console.log('handleSearchFocus: 사용자 상호작용 감지');
    showSearchPage.value = true;
  } else {
    console.log('handleSearchFocus: 개발자 도구 또는 기타 이벤트로 인한 포커스 무시');
    // 포커스를 제거하기 위해 다른 요소로 포커스 이동
    (document.activeElement as HTMLElement)?.blur();
  }
};

// 전역 F12 키 감지를 위한 변수와 이벤트 리스너 추가
window.lastKeyWasF12 = false;
document.addEventListener('keydown', (e) => {
  // F12 키 감지
  if (e.key === 'F12' || e.keyCode === 123) {
    window.lastKeyWasF12 = true;
    // 짧은 시간 후 플래그 초기화
    setTimeout(() => {
      window.lastKeyWasF12 = false;
    }, 100);
  }
});

// 검색 페이지 닫기
</script>

<style>
.app {
  font-family: 'Avenir', Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
  display: flex;
}

.sidebar {
  position: fixed;
  top: 60px;
  left: 0;
  width: 120px;
  height: 100vh;
  background-color: white;
  z-index: 90;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  padding-top: 10px;
}

.sidebar-item {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: flex-start;
  width: 100%;
  height: 40px;
  cursor: pointer;
  padding-left: 16px;
}

.sidebar-item:hover, .sidebar-item.active {
  background-color: #f0f0f0;
}

.sidebar-item.active .home-icon {
  color: #000000;
}

.sidebar-item.active .sidebar-text {
  font-weight: bold;
}

.sidebar-icon {
  width: 24px;
  height: 24px;
  margin-right: 16px;
}

.home-icon {
  width: 24px;
  height: 24px;
  fill: transparent;
  color: #606060;
}

.sidebar-text {
  font-size: 14px;
  color: #030303;
}

.menu-bar {
  background-color: white;
  width: 100%;
  position: fixed;
  top: 0;
  left: 0;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  z-index: 100;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 5px 25px;
  height: 60px;
}

.logo-container {
  display: flex;
  align-items: center;
  flex: 1;
  justify-content: flex-start;
}

.search-container {
  flex: 2;
  display: flex;
  justify-content: center;
  align-items: center;
  max-width: 640px;
}

.search-form {
  display: flex;
  width: 100%;
  max-width: 540px;
  position: relative;
}

.search-input {
  width: 100%;
  height: 38px;
  padding: 0 16px;
  font-size: 16px;
  border: 1px solid #ccc;
  border-radius: 2px 0 0 2px;
  outline: none;
}

.search-input:focus {
  border-color: #1c62b9;
  box-shadow: 0 0 0 1px #1c62b9;
}

.search-button {
  width: 64px;
  height: 40px;
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  border-left: none;
  border-radius: 0 2px 2px 0;
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;
}

.search-button:hover {
  background-color: #f0f0f0;
}

.search-icon {
  width: 24px;
  height: 24px;
  fill: #606060;
}

.action-buttons {
  display: flex;
  justify-content: flex-end;
  align-items: center;
  flex: 1;
  gap: 12px;
  margin-right: 30px;
}

.create-dropdown {
  position: relative;
}

.dropdown-menu {
  position: absolute;
  top: 100%;
  right: 0;
  width: 200px;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
  margin-top: 8px;
  z-index: 150;
  overflow: hidden;
}

.dropdown-item {
  display: flex;
  align-items: center;
  padding: 12px 16px;
  cursor: pointer;
}

.dropdown-item:hover {
  background-color: #f0f0f0;
}

.dropdown-item svg {
  width: 20px;
  height: 20px;
  margin-right: 12px;
  fill: #606060;
}

.dropdown-item span {
  font-size: 14px;
  color: #030303;
}

.create-button {
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #f1f1f1;
  border: none;
  border-radius: 25px;
  padding: 8px 16px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  color: #0f0f0f;
  height: 36px;
  min-width: 90px;
}

.create-button:hover {
  background-color: #e5e5e5;
}

.plus-icon {
  font-size: 18px;
  margin-right: 5px;
  font-weight: 300;
  line-height: 1;
}

.create-text {
  line-height: 1;
}

.notification-wrapper {
  position: relative;
  margin-right: 10px;
}

.notification-badge {
  position: absolute;
  top: -5px;
  right: -5px;
  background-color: #FF0000;
  color: white;
  border-radius: 50%;
  width: 18px;
  height: 18px;
  font-size: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
}

.notification-button {
  background-color: transparent;
  border: none;
  cursor: pointer;
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
}

.notification-button:hover {
  background-color: #f0f0f0;
}

.bell-icon {
  width: 24px;
  height: 24px;
  fill: #030303;
}

.youtube-logo {
  display: flex;
  align-items: center;
  cursor: pointer;
}

.play-button {
  width: 40px;
  height: 26px;
  background-color: #FF0000;
  border-radius: 7px;
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
}

.play-button:before {
  content: "";
  width: 0;
  height: 0;
  border-style: solid;
  border-width: 7px 0 7px 10px;
  border-color: transparent transparent transparent white;
  position: absolute;
}

.youtube-text {
  font-weight: bold;
  font-size: 20px;
  margin-left: 3px;
  font-family: 'Arial', sans-serif;
  letter-spacing: -1px;
  color: #000;
}

.kr {
  font-size: 10px;
  vertical-align: super;
  margin-left: 2px;
  font-weight: normal;
}

.menu-bar li {
  padding: 18px 22px;
}

.menu-bar a {
  text-decoration: none;
  color: #333;
  font-weight: bold;
}

header {
  margin-bottom: 30px;
  margin-top: 30px;
}

header h1 {
  color: #FF0000;
  font-size: 32px;
  font-family: 'Arial', sans-serif;
  letter-spacing: -1px;
  margin-top: 80px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.favicon-icon {
  width: 36px;
  height: 25px;
  background-color: #FF0000;
  border-radius: 7px;
  margin-right: 10px;
  position: relative;
  display: inline-flex;
  justify-content: center;
  align-items: center;
}

.favicon-icon:before {
  content: "";
  width: 0;
  height: 0;
  border-style: solid;
  border-width: 6px 0 6px 9px;
  border-color: transparent transparent transparent white;
  position: absolute;
}

footer {
  margin-top: 30px;
  font-size: 0.8em;
  color: #666;
}

/* 모달 스타일 */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 200;
}

.upload-modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 100%;
  max-width: 600px;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
  z-index: 201;
  overflow: hidden;
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 24px;
  border-bottom: 1px solid #e5e5e5;
}

.modal-header h2 {
  font-size: 18px;
  font-weight: 500;
  margin: 0;
}

.close-button {
  background: transparent;
  border: none;
  font-size: 24px;
  cursor: pointer;
  color: #606060;
}

.modal-content {
  padding: 24px;
}

.upload-area {
  border: 2px dashed #ccc;
  border-radius: 8px;
  padding: 40px 20px;
  text-align: center;
  cursor: pointer;
  margin-bottom: 20px;
}

.upload-area:hover {
  border-color: #1c62b9;
  background-color: #f8f8f8;
}

.upload-cloud-icon {
  width: 48px;
  height: 48px;
  fill: #606060;
  margin-bottom: 8px;
}

.upload-preview {
  background-color: #f8f8f8;
  border-radius: 8px;
  padding: 16px;
  margin-top: 20px;
}

.file-info {
  display: flex;
  justify-content: space-between;
  margin-bottom: 16px;
}

.file-name {
  font-weight: 500;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.upload-actions {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
}

.cancel-button {
  padding: 8px 16px;
  background-color: #f1f1f1;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.upload-button {
  padding: 8px 16px;
  background-color: #1c62b9;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.upload-progress {
  margin-top: 20px;
}

.progress-bar {
  height: 8px;
  background-color: #f1f1f1;
  border-radius: 4px;
  overflow: hidden;
  margin-bottom: 8px;
}

.progress-fill {
  height: 100%;
  background-color: #1c62b9;
  transition: width 0.3s ease;
}

.progress-text {
  text-align: right;
  font-size: 12px;
  color: #606060;
}

/* Main content styles */
.main-content {
  margin-left: 120px;
  width: calc(100% - 120px);
  padding: 20px;
  text-align: left;
}

.videos-container {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 20px;
  margin-top: 20px;
}

.no-videos {
  grid-column: 1 / -1;
  text-align: center;
  padding: 50px 0;
  color: #606060;
}

.video-card {
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  background-color: white;
  transition: transform 0.2s;
  cursor: pointer;
}

.video-card:hover {
  transform: translateY(-5px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

.video-thumbnail {
  position: relative;
  width: 100%;
  height: 0;
  padding-bottom: 56.25%; /* 16:9 aspect ratio */
  background-color: #f9f9f9;
  overflow: hidden;
}

.video-thumbnail video {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.thumbnail-placeholder {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #f5f5f5;
}

.refresh-notice {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 16px;
  text-align: center;
}

.refresh-icon {
  width: 40px;
  height: 40px;
  fill: #606060;
  margin-bottom: 12px;
}

.refresh-text {
  color: #606060;
  font-size: 14px;
  line-height: 1.4;
}

.video-placeholder-icon {
  width: 48px;
  height: 48px;
  fill: #606060;
}

.video-info {
  padding: 12px;
}

.video-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 6px;
}

.video-delete-button {
  position: absolute;
  top: 8px;
  right: 8px;
  width: 32px;
  height: 32px;
  background-color: rgba(0, 0, 0, 0.6);
  border: none;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 5;
  opacity: 0;
  transition: opacity 0.2s;
}

.video-card:hover .video-delete-button {
  opacity: 1;
}

.video-delete-button:hover {
  background-color: rgba(0, 0, 0, 0.8);
}

.trash-icon {
  width: 18px;
  height: 18px;
  fill: white;
}

.video-title {
  margin: 0;
  font-size: 16px;
  font-weight: 500;
  color: #030303;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex: 1;
  margin-right: 8px;
}

.video-details {
  display: flex;
  justify-content: space-between;
  margin: 6px 0 0;
  font-size: 12px;
  color: #606060;
}

.video-size {
  color: #606060;
}

/* 비디오 상세 폼 */
.video-details-form {
  margin-top: 20px;
  margin-bottom: 20px;
}

.form-group {
  margin-bottom: 16px;
}

.form-group label {
  display: block;
  margin-bottom: 8px;
  font-weight: 500;
  color: #030303;
  text-align: left;
}

.form-group input {
  width: 100%;
  padding: 10px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 14px;
}

/* 알림 창 스타일 */
.notification-container {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 1000;
}

.notification {
  display: flex;
  align-items: flex-start;
  width: 320px;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  overflow: hidden;
  padding: 16px;
  animation: slide-in 0.3s ease-out;
}

@keyframes slide-in {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

.notification.success {
  border-left: 4px solid #4CAF50;
}

.notification.error {
  border-left: 4px solid #F44336;
}

.notification-icon {
  margin-right: 12px;
  flex-shrink: 0;
}

.success-icon {
  width: 24px;
  height: 24px;
  fill: #4CAF50;
}

.error-icon {
  width: 24px;
  height: 24px;
  fill: #F44336;
}

.notification-content {
  flex: 1;
}

.notification-title {
  font-weight: 500;
  margin-bottom: 4px;
  color: #333;
}

.notification-message {
  font-size: 14px;
  color: #666;
}

.notification-close {
  background: transparent;
  border: none;
  cursor: pointer;
  padding: 0;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-left: 8px;
  opacity: 0.5;
  transition: opacity 0.2s;
}

.notification-close:hover {
  opacity: 1;
}

.close-icon {
  width: 16px;
  height: 16px;
  fill: #666;
}

/* 알림 패널 스타일 */
.notification-panel {
  position: absolute;
  top: 100%;
  right: 0;
  width: 320px;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  margin-top: 8px;
  z-index: 200;
  overflow: hidden;
  max-height: 500px;
  display: flex;
  flex-direction: column;
}

.notification-panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 16px;
  border-bottom: 1px solid #e5e5e5;
}

.notification-panel-header h3 {
  margin: 0;
  font-size: 16px;
  font-weight: 500;
}

.clear-all {
  background: none;
  border: none;
  color: #065fd4;
  font-size: 14px;
  cursor: pointer;
  padding: 4px 8px;
}

.clear-all:hover {
  background-color: #f0f0f0;
  border-radius: 4px;
}

.notification-panel-content {
  overflow-y: auto;
  max-height: 450px;
}

.no-notifications {
  padding: 32px 16px;
  text-align: center;
  color: #606060;
  font-size: 14px;
}

.notification-item {
  display: flex;
  padding: 12px 16px;
  border-bottom: 1px solid #e5e5e5;
  cursor: pointer;
}

.notification-item:hover {
  background-color: #f9f9f9;
}

.notification-item-icon {
  margin-right: 12px;
  flex-shrink: 0;
}

.notification-item-content {
  flex: 1;
}

.notification-item-title {
  font-weight: 500;
  margin-bottom: 4px;
  color: #030303;
}

.notification-item-message {
  font-size: 14px;
  color: #606060;
  margin-bottom: 4px;
}

.notification-item-time {
  font-size: 12px;
  color: #909090;
}

/* 검색 결과 헤더 스타일 */
header h2 {
  font-size: 18px;
  font-weight: 500;
  color: #030303;
  margin: 16px 0;
  padding-left: 10px;
}

.search-clear-button {
  position: absolute;
  right: 72px;
  top: 50%;
  transform: translateY(-50%);
  background: transparent;
  border: none;
  height: 40px;
  width: 40px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0.6;
}

.search-clear-button:hover {
  opacity: 1;
}

.clear-icon {
  width: 18px;
  height: 18px;
  fill: #606060;
}

.search-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 16px 0;
  padding: 0 10px;
}

.search-header h2 {
  font-size: 18px;
  font-weight: 500;
  color: #030303;
  margin: 0;
}

.reset-search-button {
  background-color: #f0f0f0;
  border: none;
  border-radius: 18px;
  padding: 6px 12px;
  display: flex;
  align-items: center;
  cursor: pointer;
  font-size: 14px;
  color: #606060;
  transition: background-color 0.2s;
}

.reset-search-button:hover {
  background-color: #e0e0e0;
}

.reset-icon {
  width: 16px;
  height: 16px;
  fill: #606060;
  margin-right: 4px;
}

/* 검색 결과 드롭다운 스타일 */
.search-results-dropdown {
  position: absolute;
  top: 40px;
  left: 0;
  width: 100%;
  background: white;
  border-radius: 0 0 4px 4px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
  z-index: 150;
  max-height: 400px;
  overflow-y: auto;
}

.no-results {
  padding: 16px;
  text-align: center;
  color: #606060;
}

.search-results-list {
  display: flex;
  flex-direction: column;
}

.search-result-item {
  display: flex;
  align-items: center;
  padding: 8px 16px;
  cursor: pointer;
  border-bottom: 1px solid #f0f0f0;
}

.search-result-item:hover {
  background-color: #f8f8f8;
}

.search-result-thumbnail {
  width: 120px;
  height: 68px;
  margin-right: 12px;
  background-color: #f0f0f0;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  overflow: hidden;
}

.search-result-thumbnail video {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.search-result-info {
  flex: 1;
  text-align: left;
}

.search-result-title {
  font-size: 14px;
  font-weight: 500;
  color: #030303;
  margin-bottom: 4px;
}

.search-result-meta {
  font-size: 12px;
  color: #606060;
}

.search-clear-button {
  position: absolute;
  right: 70px;
  top: 50%;
  transform: translateY(-50%);
  background: transparent;
  border: none;
  cursor: pointer;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
}

.search-clear-button .clear-icon {
  width: 18px;
  height: 18px;
  fill: #606060;
}

/* 쇼츠 컨테이너 스타일 */
.shorts-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px 0;
  width: 100%;
  min-height: calc(100vh - 130px);
  background-color: #f9f9f9;
  overflow-y: auto;
}

.shorts-no-videos {
  color: #333;
  background-color: transparent;
}

.shorts-list {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
  gap: 20px;
  max-width: 720px;
  margin: 0 auto;
}

.shorts-card {
  background-color: #fff;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  width: 420px;
  max-width: 100%;
  height: 800px;
  display: flex;
  flex-direction: column;
  margin-bottom: 20px;
  position: relative;
}

.shorts-thumbnail {
  position: relative;
  width: 100%;
  height: 700px;
  background-color: #000;
  overflow: hidden;
}

.shorts-thumbnail video,
.shorts-thumbnail .thumbnail-placeholder {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: contain;
  display: flex;
  justify-content: center;
  align-items: center;
}

.shorts-info {
  position: relative;
  bottom: auto;
  left: auto;
  width: 100%;
  padding: 16px;
  background: #fff;
  color: #333;
  z-index: 10;
  border-top: 1px solid #f0f0f0;
}

.shorts-title {
  font-size: 16px;
  font-weight: 500;
  margin: 0;
  line-height: 1.3;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  color: #030303;
}

.shorts-details {
  font-size: 14px;
  color: #606060;
  margin: 4px 0 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.shorts-channel {
  font-weight: 500;
}

.shorts-controls {
  position: absolute;
  bottom: 80px;
  right: 12px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  padding: 0;
  z-index: 15;
}

.shorts-like,
.shorts-dislike,
.shorts-comment,
.shorts-share {
  display: flex;
  flex-direction: column;
  align-items: center;
  color: white;
  font-size: 12px;
  gap: 8px;
  cursor: pointer;
}

.like-icon,
.dislike-icon,
.comment-icon,
.share-icon {
  width: 24px;
  height: 24px;
  fill: white;
}

.shorts-duration {
  background-color: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 1px 4px;
  border-radius: 2px;
  font-size: 11px;
}

.shorts-icon {
  width: 24px;
  height: 24px;
  fill: currentColor;
}

/* 삭제된 쇼츠 스타일 복원 */
.shorts-delete-button {
  z-index: 20;
  top: 15px;
}

/* 쇼츠 메뉴 버튼 */
.shorts-menu-button {
  position: absolute;
  top: 12px;
  right: 12px;
  width: 32px;
  height: 32px;
  background-color: rgba(0, 0, 0, 0.6);
  border: none;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 20;
}

.shorts-menu-button:hover {
  background-color: rgba(0, 0, 0, 0.8);
}

.menu-icon {
  width: 20px;
  height: 20px;
  fill: white;
}

.shorts-menu-dropdown {
  position: absolute;
  top: 50px;
  right: 12px;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
  overflow: hidden;
  z-index: 30;
  min-width: 120px;
}

.menu-item {
  display: flex;
  align-items: center;
  padding: 10px 16px;
  cursor: pointer;
}

.menu-item:hover {
  background-color: #f0f0f0;
}

.delete-icon {
  width: 20px;
  height: 20px;
  fill: #606060;
  margin-right: 12px;
}

.menu-item span {
  font-size: 14px;
  color: #030303;
}

/* 삭제 모달 스타일 */
.delete-modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
  z-index: 210;
  width: 100%;
  max-width: 400px;
}

.delete-actions {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  margin-top: 20px;
}

.delete-button {
  padding: 8px 16px;
  background-color: #cc0000;
  color: white;
  border: none;
  border-radius: 2px;
  cursor: pointer;
  font-weight: 500;
}

.delete-button:hover {
  background-color: #b00000;
}

.view-header {
  margin: 20px 0;
  padding: 0 10px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.view-header-content {
  flex: 1;
}

.view-header h2 {
  font-size: 20px;
  font-weight: 500;
  margin: 0 0 8px 0;
}

.view-header p {
  font-size: 14px;
  color: #606060;
  margin: 0;
}

/* 시청기록 페이지 스타일 */
.history-icon {
  width: 24px;
  height: 24px;
  fill: #606060;
}

.sidebar-item.active .history-icon {
  fill: #FF0000;
}

.history-item {
  margin-bottom: 16px;
  border-bottom: 1px solid #f0f0f0;
  padding-bottom: 16px;
}

.watched-date {
  font-style: italic;
  color: #606060;
}

.remove-history-button {
  margin-top: 8px;
  background: none;
  border: none;
  color: #606060;
  font-size: 12px;
  padding: 4px 8px;
  border-radius: 2px;
  cursor: pointer;
  display: flex;
  align-items: center;
  transition: background-color 0.2s;
  max-width: fit-content;
}

.remove-history-button:hover {
  background-color: #f0f0f0;
}

.remove-icon {
  width: 14px;
  height: 14px;
  fill: #606060;
  margin-right: 4px;
}

/* 비디오 상세 모달 */
.video-detail-container {
  padding: 0;
  width: 100%;
  max-width: 1800px;
  margin: 0 auto;
  display: flex;
  flex-direction: column;
}

.video-content-wrapper {
  display: flex;
  width: 100%;
  padding: 0 20px;
  margin-top: 20px;
}

.video-main-content {
  flex: 1;
  width: 100%;
  max-width: 1280px;
  margin: 0 auto;
}

.video-sidebar {
  flex: 1;
  min-width: 300px;
  max-width: 400px;
}

.video-detail-header {
  display: flex;
  align-items: center;
  margin-bottom: 20px;
  padding: 0 20px;
}

.back-button {
  display: flex;
  align-items: center;
  background: none;
  border: none;
  cursor: pointer;
  padding: 8px;
  margin-right: 16px;
  border-radius: 50%;
  transition: background-color 0.2s;
}

.back-button:hover {
  background-color: #f0f0f0;
}

.back-icon {
  width: 24px;
  height: 24px;
  fill: #606060;
}

.video-player-container {
  width: 100%;
  background-color: #000;
  position: relative;
  padding-top: 56.25%; /* 16:9 비율 유지 */
  border-radius: 0;
  overflow: hidden;
  margin: 0 auto;
}

.video-player-container video {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.video-detail-info {
  padding: 20px 0;
  border-bottom: 1px solid #e5e5e5;
}

.video-detail-title {
  font-size: 18px;
  font-weight: 500;
  margin-bottom: 12px;
  color: #030303;
}

.video-detail-stats {
  display: flex;
  align-items: center;
  margin-bottom: 16px;
}

.video-detail-views {
  font-weight: 500;
  color: #030303;
  margin-right: 5px;
}

.video-detail-date {
  font-size: 14px;
  color: #606060;
}

.video-actions {
  display: flex;
  gap: 16px;
  margin-top: 12px;
}

.video-action-button {
  display: flex;
  flex-direction: column;
  align-items: center;
  cursor: pointer;
}

.video-action-button svg {
  width: 24px;
  height: 24px;
  fill: #606060;
  margin-bottom: 6px;
}

.video-action-button span {
  font-size: 12px;
  color: #606060;
}

.video-recommendations {
  padding: 0;
}

.video-recommendations h3 {
  font-size: 16px;
  font-weight: 500;
  margin: 0 0 12px 0;
}

.recommended-videos {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.recommended-video {
  display: flex;
  cursor: pointer;
  padding: 8px;
  border-radius: 4px;
  transition: background-color 0.2s;
}

.recommended-video:hover {
  background-color: #f0f0f0;
}

.recommended-thumbnail {
  width: 168px;
  height: 94px;
  border-radius: 4px;
  overflow: hidden;
  margin-right: 8px;
  background-color: #f5f5f5;
  position: relative;
  flex-shrink: 0;
}

.recommended-thumbnail video,
.recommended-thumbnail .thumbnail-placeholder {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.recommended-duration {
  position: absolute;
  bottom: 4px;
  right: 4px;
  background-color: rgba(0, 0, 0, 0.8);
  color: white;
  font-size: 12px;
  padding: 1px 4px;
  border-radius: 2px;
}

.recommended-info {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.recommended-title {
  font-size: 14px;
  font-weight: 500;
  margin-bottom: 4px;
  color: #030303;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
  text-overflow: ellipsis;
}

.recommended-meta {
  font-size: 12px;
  color: #606060;
}

/* 동영상 상세 페이지 좋아요 버튼 스타일 */
.video-actions {
  display: flex;
  align-items: center;
  margin-top: 16px;
  gap: 20px;
}

.video-action-button {
  display: flex;
  flex-direction: column;
  align-items: center;
  cursor: pointer;
  padding: 8px;
  border-radius: 4px;
}

.video-action-button:hover {
  background-color: #f0f0f0;
}

.action-icon {
  width: 24px;
  height: 24px;
  fill: #606060;
  margin-bottom: 4px;
}

.video-action-button span {
  font-size: 13px;
  color: #606060;
}

.action-icon.liked {
  fill: #4285F4;
}

.action-icon.disliked {
  fill: #FF0000;
}

/* 댓글 섹션 스타일 */
.comments-section {
  margin-top: 24px;
  padding-top: 24px;
  border-top: 1px solid #e5e5e5;
}

.comments-title {
  font-size: 16px;
  font-weight: 500;
  margin-bottom: 24px;
}

.comment-form {
  display: flex;
  margin-bottom: 32px;
}

.comment-form-avatar,
.comment-avatar {
  width: 40px;
  height: 40px;
  flex-shrink: 0;
  margin-right: 16px;
}

.user-icon {
  width: 40px;
  height: 40px;
  fill: #909090;
  background-color: #f0f0f0;
  border-radius: 50%;
}

.comment-form-content {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.comment-input {
  border: none;
  border-bottom: 1px solid #e5e5e5;
  padding: 8px 0;
  margin-bottom: 8px;
  font-size: 14px;
  outline: none;
  width: 100%;
}

.comment-input:focus {
  border-bottom-color: #1c62b9;
}

.comment-submit {
  align-self: flex-end;
  padding: 8px 16px;
  background-color: #1c62b9;
  color: white;
  border: none;
  border-radius: 2px;
  cursor: pointer;
  font-size: 14px;
}

.comment-submit:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}

.comments-list {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

.no-comments {
  text-align: center;
  color: #606060;
  padding: 24px 0;
}

.comment-item {
  display: flex;
}

.comment-content {
  flex: 1;
}

.comment-header {
  display: flex;
  align-items: center;
  margin-bottom: 4px;
}

.comment-author {
  font-weight: 500;
  font-size: 13px;
  margin-right: 8px;
}

.comment-date {
  font-size: 12px;
  color: #606060;
}

.comment-text {
  font-size: 14px;
  line-height: 1.4;
  margin-bottom: 8px;
}

.comment-actions {
  display: flex;
  align-items: center;
  gap: 16px;
}

.comment-like {
  display: flex;
  align-items: center;
  cursor: pointer;
}

.like-icon {
  width: 16px;
  height: 16px;
  fill: #606060;
  margin-right: 4px;
}

.comment-delete {
  background: none;
  border: none;
  color: #606060;
  font-size: 12px;
  cursor: pointer;
  padding: 4px 8px;
}

.comment-delete:hover {
  background-color: #f0f0f0;
  border-radius: 2px;
}

.comments-loading {
  text-align: center;
  padding: 24px 0;
  color: #606060;
}

/* 비디오 좋아요 상태 스타일 */
.liked {
  fill: #1c62b9 !important;
}

/* 시청 기록 비우기 버튼 스타일 */
.clear-history-button {
  background-color: #f0f0f0;
  border: none;
  border-radius: 20px;
  padding: 6px 12px;
  display: flex;
  align-items: center;
  font-size: 13px;
  color: #606060;
  cursor: pointer;
  transition: background-color 0.2s;
}

.clear-history-button:hover {
  background-color: #e0e0e0;
}

.clear-history-button .delete-all-icon {
  width: 16px;
  height: 16px;
  fill: #606060;
  margin-right: 4px;
}
</style> 